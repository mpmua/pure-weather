{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent } from '@stencil/core/internal/client';\nimport { c as componentOnReady, q as debounce } from './helpers.js';\nvar ROUTER_INTENT_NONE = 'root';\nvar ROUTER_INTENT_FORWARD = 'forward';\nvar ROUTER_INTENT_BACK = 'back';\n\n/** Join the non empty segments with \"/\". */\nvar generatePath = function generatePath(segments) {\n  var path = segments.filter(function (s) {\n    return s.length > 0;\n  }).join('/');\n  return '/' + path;\n};\nvar generateUrl = function generateUrl(segments, useHash, queryString) {\n  var url = generatePath(segments);\n  if (useHash) {\n    url = '#' + url;\n  }\n  if (queryString !== undefined) {\n    url += '?' + queryString;\n  }\n  return url;\n};\nvar writeSegments = function writeSegments(history, root, useHash, segments, direction, state, queryString) {\n  var url = generateUrl([].concat(_toConsumableArray(parsePath(root).segments), _toConsumableArray(segments)), useHash, queryString);\n  if (direction === ROUTER_INTENT_FORWARD) {\n    history.pushState(state, '', url);\n  } else {\n    history.replaceState(state, '', url);\n  }\n};\n/**\n * Transforms a chain to a list of segments.\n *\n * Notes:\n * - parameter segments of the form :param are replaced with their value,\n * - null is returned when a value is missing for any parameter segment.\n */\nvar chainToSegments = function chainToSegments(chain) {\n  var segments = [];\n  var _iterator = _createForOfIteratorHelper(chain),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var route = _step.value;\n      var _iterator2 = _createForOfIteratorHelper(route.segments),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var segment = _step2.value;\n          if (segment[0] === ':') {\n            var param = route.params && route.params[segment.slice(1)];\n            if (!param) {\n              return null;\n            }\n            segments.push(param);\n          } else if (segment !== '') {\n            segments.push(segment);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return segments;\n};\n/**\n * Removes the prefix segments from the path segments.\n *\n * Return:\n * - null when the path segments do not start with the passed prefix,\n * - the path segments after the prefix otherwise.\n */\nvar removePrefix = function removePrefix(prefix, segments) {\n  if (prefix.length > segments.length) {\n    return null;\n  }\n  if (prefix.length <= 1 && prefix[0] === '') {\n    return segments;\n  }\n  for (var i = 0; i < prefix.length; i++) {\n    if (prefix[i] !== segments[i]) {\n      return null;\n    }\n  }\n  if (segments.length === prefix.length) {\n    return [''];\n  }\n  return segments.slice(prefix.length);\n};\nvar readSegments = function readSegments(loc, root, useHash) {\n  var prefix = parsePath(root).segments;\n  var pathname = useHash ? loc.hash.slice(1) : loc.pathname;\n  var segments = parsePath(pathname).segments;\n  return removePrefix(prefix, segments);\n};\n/**\n * Parses the path to:\n * - segments an array of '/' separated parts,\n * - queryString (undefined when no query string).\n */\nvar parsePath = function parsePath(path) {\n  var segments = [''];\n  var queryString;\n  if (path != null) {\n    var qsStart = path.indexOf('?');\n    if (qsStart > -1) {\n      queryString = path.substring(qsStart + 1);\n      path = path.substring(0, qsStart);\n    }\n    segments = path.split('/').map(function (s) {\n      return s.trim();\n    }).filter(function (s) {\n      return s.length > 0;\n    });\n    if (segments.length === 0) {\n      segments = [''];\n    }\n  }\n  return {\n    segments: segments,\n    queryString: queryString\n  };\n};\nvar printRoutes = function printRoutes(routes) {\n  console.group(\"[ion-core] ROUTES[\".concat(routes.length, \"]\"));\n  var _iterator3 = _createForOfIteratorHelper(routes),\n    _step3;\n  try {\n    var _loop = function _loop() {\n      var chain = _step3.value;\n      var segments = [];\n      chain.forEach(function (r) {\n        return segments.push.apply(segments, _toConsumableArray(r.segments));\n      });\n      var ids = chain.map(function (r) {\n        return r.id;\n      });\n      console.debug(\"%c \".concat(generatePath(segments)), 'font-weight: bold; padding-left: 20px', '=>\\t', \"(\".concat(ids.join(', '), \")\"));\n    };\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  console.groupEnd();\n};\nvar printRedirects = function printRedirects(redirects) {\n  console.group(\"[ion-core] REDIRECTS[\".concat(redirects.length, \"]\"));\n  var _iterator4 = _createForOfIteratorHelper(redirects),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var redirect = _step4.value;\n      if (redirect.to) {\n        console.debug('FROM: ', \"$c \".concat(generatePath(redirect.from)), 'font-weight: bold', ' TO: ', \"$c \".concat(generatePath(redirect.to.segments)), 'font-weight: bold');\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  console.groupEnd();\n};\n\n/**\n * Activates the passed route chain.\n *\n * There must be exactly one outlet per route entry in the chain.\n *\n * The methods calls setRouteId on each of the outlet with the corresponding route entry in the chain.\n * setRouteId will create or select the view in the outlet.\n */\nvar _writeNavState = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(root, chain, direction, index) {\n    var changed,\n      animation,\n      outlet,\n      route,\n      result,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          changed = _args.length > 4 && _args[4] !== undefined ? _args[4] : false;\n          animation = _args.length > 5 ? _args[5] : undefined;\n          _context.prev = 2;\n          // find next navigation outlet in the DOM\n          outlet = searchNavNode(root); // make sure we can continue interacting the DOM, otherwise abort\n          if (!(index >= chain.length || !outlet)) {\n            _context.next = 6;\n            break;\n          }\n          return _context.abrupt(\"return\", changed);\n        case 6:\n          _context.next = 8;\n          return new Promise(function (resolve) {\n            return componentOnReady(outlet, resolve);\n          });\n        case 8:\n          route = chain[index];\n          _context.next = 11;\n          return outlet.setRouteId(route.id, route.params, direction, animation);\n        case 11:\n          result = _context.sent;\n          // if the outlet changed the page, reset navigation to neutral (no direction)\n          // this means nested outlets will not animate\n          if (result.changed) {\n            direction = ROUTER_INTENT_NONE;\n            changed = true;\n          }\n          // recursively set nested outlets\n          _context.next = 15;\n          return _writeNavState(result.element, chain, direction, index + 1, changed, animation);\n        case 15:\n          changed = _context.sent;\n          if (!result.markVisible) {\n            _context.next = 19;\n            break;\n          }\n          _context.next = 19;\n          return result.markVisible();\n        case 19:\n          return _context.abrupt(\"return\", changed);\n        case 22:\n          _context.prev = 22;\n          _context.t0 = _context[\"catch\"](2);\n          console.error(_context.t0);\n          return _context.abrupt(\"return\", false);\n        case 26:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[2, 22]]);\n  }));\n  return function writeNavState(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Recursively walks the outlet in the DOM.\n *\n * The function returns a list of RouteID corresponding to each of the outlet and the last outlet without a RouteID.\n */\nvar readNavState = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(root) {\n    var ids, outlet, node, id;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          ids = [];\n          node = root; // eslint-disable-next-line no-cond-assign\n        case 2:\n          if (!(outlet = searchNavNode(node))) {\n            _context2.next = 15;\n            break;\n          }\n          _context2.next = 5;\n          return outlet.getRouteId();\n        case 5:\n          id = _context2.sent;\n          if (!id) {\n            _context2.next = 12;\n            break;\n          }\n          node = id.element;\n          id.element = undefined;\n          ids.push(id);\n          _context2.next = 13;\n          break;\n        case 12:\n          return _context2.abrupt(\"break\", 15);\n        case 13:\n          _context2.next = 2;\n          break;\n        case 15:\n          return _context2.abrupt(\"return\", {\n            ids: ids,\n            outlet: outlet\n          });\n        case 16:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function readNavState(_x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nvar waitUntilNavNode = function waitUntilNavNode() {\n  if (searchNavNode(document.body)) {\n    return Promise.resolve();\n  }\n  return new Promise(function (resolve) {\n    window.addEventListener('ionNavWillLoad', function () {\n      return resolve();\n    }, {\n      once: true\n    });\n  });\n};\n/** Selector for all the outlets supported by the router. */\nvar OUTLET_SELECTOR = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\nvar searchNavNode = function searchNavNode(root) {\n  if (!root) {\n    return undefined;\n  }\n  if (root.matches(OUTLET_SELECTOR)) {\n    return root;\n  }\n  var outlet = root.querySelector(OUTLET_SELECTOR);\n  return outlet !== null && outlet !== void 0 ? outlet : undefined;\n};\n\n/**\n * Returns whether the given redirect matches the given path segments.\n *\n * A redirect matches when the segments of the path and redirect.from are equal.\n * Note that segments are only checked until redirect.from contains a '*' which matches any path segment.\n * The path ['some', 'path', 'to', 'page'] matches both ['some', 'path', 'to', 'page'] and ['some', 'path', '*'].\n */\nvar matchesRedirect = function matchesRedirect(segments, redirect) {\n  var from = redirect.from,\n    to = redirect.to;\n  if (to === undefined) {\n    return false;\n  }\n  if (from.length > segments.length) {\n    return false;\n  }\n  for (var i = 0; i < from.length; i++) {\n    var expected = from[i];\n    if (expected === '*') {\n      return true;\n    }\n    if (expected !== segments[i]) {\n      return false;\n    }\n  }\n  return from.length === segments.length;\n};\n/** Returns the first redirect matching the path segments or undefined when no match found. */\nvar findRouteRedirect = function findRouteRedirect(segments, redirects) {\n  return redirects.find(function (redirect) {\n    return matchesRedirect(segments, redirect);\n  });\n};\nvar matchesIDs = function matchesIDs(ids, chain) {\n  var len = Math.min(ids.length, chain.length);\n  var score = 0;\n  for (var i = 0; i < len; i++) {\n    var routeId = ids[i];\n    var routeChain = chain[i];\n    // Skip results where the route id does not match the chain at the same index\n    if (routeId.id.toLowerCase() !== routeChain.id) {\n      break;\n    }\n    if (routeId.params) {\n      var routeIdParams = Object.keys(routeId.params);\n      // Only compare routes with the chain that have the same number of parameters.\n      if (routeIdParams.length === routeChain.segments.length) {\n        // Maps the route's params into a path based on the path variable names,\n        // to compare against the route chain format.\n        //\n        // Before:\n        // ```ts\n        // {\n        //  params: {\n        //    s1: 'a',\n        //    s2: 'b'\n        //  }\n        // }\n        // ```\n        //\n        // After:\n        // ```ts\n        // [':s1',':s2']\n        // ```\n        //\n        var pathWithParams = routeIdParams.map(function (key) {\n          return \":\".concat(key);\n        });\n        for (var j = 0; j < pathWithParams.length; j++) {\n          // Skip results where the path variable is not a match\n          if (pathWithParams[j].toLowerCase() !== routeChain.segments[j]) {\n            break;\n          }\n          // Weight path matches for the same index higher.\n          score++;\n        }\n      }\n    }\n    // Weight id matches\n    score++;\n  }\n  return score;\n};\n/**\n * Matches the segments against the chain.\n *\n * Returns:\n * - null when there is no match,\n * - a chain with the params properties updated with the parameter segments on match.\n */\nvar matchesSegments = function matchesSegments(segments, chain) {\n  var inputSegments = new RouterSegments(segments);\n  var matchesDefault = false;\n  var allparams;\n  for (var i = 0; i < chain.length; i++) {\n    var chainSegments = chain[i].segments;\n    if (chainSegments[0] === '') {\n      matchesDefault = true;\n    } else {\n      var _iterator5 = _createForOfIteratorHelper(chainSegments),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var segment = _step5.value;\n          var data = inputSegments.next();\n          // data param\n          if (segment[0] === ':') {\n            if (data === '') {\n              return null;\n            }\n            allparams = allparams || [];\n            var params = allparams[i] || (allparams[i] = {});\n            params[segment.slice(1)] = data;\n          } else if (data !== segment) {\n            return null;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      matchesDefault = false;\n    }\n  }\n  var matches = matchesDefault ? matchesDefault === (inputSegments.next() === '') : true;\n  if (!matches) {\n    return null;\n  }\n  if (allparams) {\n    return chain.map(function (route, i) {\n      return {\n        id: route.id,\n        segments: route.segments,\n        params: mergeParams(route.params, allparams[i]),\n        beforeEnter: route.beforeEnter,\n        beforeLeave: route.beforeLeave\n      };\n    });\n  }\n  return chain;\n};\n/**\n * Merges the route parameter objects.\n * Returns undefined when both parameters are undefined.\n */\nvar mergeParams = function mergeParams(a, b) {\n  return a || b ? Object.assign(Object.assign({}, a), b) : undefined;\n};\n/**\n * Finds the best match for the ids in the chains.\n *\n * Returns the best match or null when no match is found.\n * When a chain is returned the parameters are updated from the RouteIDs.\n * That is they contain both the componentProps of the <ion-route> and the parameter segment.\n */\nvar findChainForIDs = function findChainForIDs(ids, chains) {\n  var match = null;\n  var maxMatches = 0;\n  var _iterator6 = _createForOfIteratorHelper(chains),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var chain = _step6.value;\n      var score = matchesIDs(ids, chain);\n      if (score > maxMatches) {\n        match = chain;\n        maxMatches = score;\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  if (match) {\n    return match.map(function (route, i) {\n      var _a;\n      return {\n        id: route.id,\n        segments: route.segments,\n        params: mergeParams(route.params, (_a = ids[i]) === null || _a === void 0 ? void 0 : _a.params)\n      };\n    });\n  }\n  return null;\n};\n/**\n * Finds the best match for the segments in the chains.\n *\n * Returns the best match or null when no match is found.\n * When a chain is returned the parameters are updated from the segments.\n * That is they contain both the componentProps of the <ion-route> and the parameter segments.\n */\nvar findChainForSegments = function findChainForSegments(segments, chains) {\n  var match = null;\n  var bestScore = 0;\n  var _iterator7 = _createForOfIteratorHelper(chains),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var chain = _step7.value;\n      var matchedChain = matchesSegments(segments, chain);\n      if (matchedChain !== null) {\n        var score = computePriority(matchedChain);\n        if (score > bestScore) {\n          bestScore = score;\n          match = matchedChain;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return match;\n};\n/**\n * Computes the priority of a chain.\n *\n * Parameter segments are given a lower priority over fixed segments.\n *\n * Considering the following 2 chains matching the path /path/to/page:\n * - /path/to/:where\n * - /path/to/page\n *\n * The second one will be given a higher priority because \"page\" is a fixed segment (vs \":where\", a parameter segment).\n */\nvar computePriority = function computePriority(chain) {\n  var score = 1;\n  var level = 1;\n  var _iterator8 = _createForOfIteratorHelper(chain),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var route = _step8.value;\n      var _iterator9 = _createForOfIteratorHelper(route.segments),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var segment = _step9.value;\n          if (segment[0] === ':') {\n            score += Math.pow(1, level);\n          } else if (segment !== '') {\n            score += Math.pow(2, level);\n          }\n          level++;\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  return score;\n};\nvar RouterSegments = /*#__PURE__*/function () {\n  function RouterSegments(segments) {\n    _classCallCheck(this, RouterSegments);\n    this.segments = segments.slice();\n  }\n  _createClass(RouterSegments, [{\n    key: \"next\",\n    value: function next() {\n      if (this.segments.length > 0) {\n        return this.segments.shift();\n      }\n      return '';\n    }\n  }]);\n  return RouterSegments;\n}();\nvar readProp = function readProp(el, prop) {\n  if (prop in el) {\n    return el[prop];\n  }\n  if (el.hasAttribute(prop)) {\n    return el.getAttribute(prop);\n  }\n  return null;\n};\n/**\n * Extracts the redirects (that is <ion-route-redirect> elements inside the root).\n *\n * The redirects are returned as a list of RouteRedirect.\n */\nvar readRedirects = function readRedirects(root) {\n  return Array.from(root.children).filter(function (el) {\n    return el.tagName === 'ION-ROUTE-REDIRECT';\n  }).map(function (el) {\n    var to = readProp(el, 'to');\n    return {\n      from: parsePath(readProp(el, 'from')).segments,\n      to: to == null ? undefined : parsePath(to)\n    };\n  });\n};\n/**\n * Extracts all the routes (that is <ion-route> elements inside the root).\n *\n * The routes are returned as a list of chains - the flattened tree.\n */\nvar readRoutes = function readRoutes(root) {\n  return flattenRouterTree(readRouteNodes(root));\n};\n/**\n * Reads the route nodes as a tree modeled after the DOM tree of <ion-route> elements.\n *\n * Note: routes without a component are ignored together with their children.\n */\nvar readRouteNodes = function readRouteNodes(node) {\n  return Array.from(node.children).filter(function (el) {\n    return el.tagName === 'ION-ROUTE' && el.component;\n  }).map(function (el) {\n    var component = readProp(el, 'component');\n    return {\n      segments: parsePath(readProp(el, 'url')).segments,\n      id: component.toLowerCase(),\n      params: el.componentProps,\n      beforeLeave: el.beforeLeave,\n      beforeEnter: el.beforeEnter,\n      children: readRouteNodes(el)\n    };\n  });\n};\n/**\n * Flattens a RouterTree in a list of chains.\n *\n * Each chain represents a path from the root node to a terminal node.\n */\nvar flattenRouterTree = function flattenRouterTree(nodes) {\n  var chains = [];\n  var _iterator10 = _createForOfIteratorHelper(nodes),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var node = _step10.value;\n      flattenNode([], chains, node);\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return chains;\n};\n/** Flattens a route node recursively and push each branch to the chains list. */\nvar flattenNode = function flattenNode(chain, chains, node) {\n  chain = [].concat(_toConsumableArray(chain), [{\n    id: node.id,\n    segments: node.segments,\n    params: node.params,\n    beforeLeave: node.beforeLeave,\n    beforeEnter: node.beforeEnter\n  }]);\n  if (node.children.length === 0) {\n    chains.push(chain);\n    return;\n  }\n  var _iterator11 = _createForOfIteratorHelper(node.children),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var child = _step11.value;\n      flattenNode(chain, chains, child);\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n};\nvar Router = /*@__PURE__*/proxyCustomElement( /*#__PURE__*/function (_HTMLElement) {\n  _inherits(Router, _HTMLElement);\n  function Router() {\n    var _this;\n    _classCallCheck(this, Router);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Router).call(this));\n    _this.__registerHost();\n    _this.ionRouteWillChange = createEvent(_assertThisInitialized(_assertThisInitialized(_this)), \"ionRouteWillChange\", 7);\n    _this.ionRouteDidChange = createEvent(_assertThisInitialized(_assertThisInitialized(_this)), \"ionRouteDidChange\", 7);\n    _this.previousPath = null;\n    _this.busy = false;\n    _this.state = 0;\n    _this.lastState = 0;\n    _this.root = '/';\n    _this.useHash = true;\n    return _this;\n  }\n  _createClass(Router, [{\n    key: \"componentWillLoad\",\n    value: function () {\n      var _componentWillLoad = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var canProceed, redirect, path;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return waitUntilNavNode();\n            case 2:\n              _context3.next = 4;\n              return this.runGuards(this.getSegments());\n            case 4:\n              canProceed = _context3.sent;\n              if (!(canProceed !== true)) {\n                _context3.next = 14;\n                break;\n              }\n              if (!(typeof canProceed === 'object')) {\n                _context3.next = 12;\n                break;\n              }\n              redirect = canProceed.redirect;\n              path = parsePath(redirect);\n              this.setSegments(path.segments, ROUTER_INTENT_NONE, path.queryString);\n              _context3.next = 12;\n              return this.writeNavStateRoot(path.segments, ROUTER_INTENT_NONE);\n            case 12:\n              _context3.next = 16;\n              break;\n            case 14:\n              _context3.next = 16;\n              return this.onRoutesChanged();\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function componentWillLoad() {\n        return _componentWillLoad.apply(this, arguments);\n      }\n      return componentWillLoad;\n    }()\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\n      window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\n    }\n  }, {\n    key: \"onPopState\",\n    value: function () {\n      var _onPopState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var direction, segments, canProceed;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              direction = this.historyDirection();\n              segments = this.getSegments();\n              _context4.next = 4;\n              return this.runGuards(segments);\n            case 4:\n              canProceed = _context4.sent;\n              if (!(canProceed !== true)) {\n                _context4.next = 11;\n                break;\n              }\n              if (!(typeof canProceed === 'object')) {\n                _context4.next = 10;\n                break;\n              }\n              segments = parsePath(canProceed.redirect).segments;\n              _context4.next = 11;\n              break;\n            case 10:\n              return _context4.abrupt(\"return\", false);\n            case 11:\n              return _context4.abrupt(\"return\", this.writeNavStateRoot(segments, direction));\n            case 12:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function onPopState() {\n        return _onPopState.apply(this, arguments);\n      }\n      return onPopState;\n    }()\n  }, {\n    key: \"onBackButton\",\n    value: function onBackButton(ev) {\n      var _this2 = this;\n      ev.detail.register(0, function (processNextHandler) {\n        _this2.back();\n        processNextHandler();\n      });\n    } /** @internal */\n  }, {\n    key: \"canTransition\",\n    value: function () {\n      var _canTransition = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var canProceed;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return this.runGuards();\n            case 2:\n              canProceed = _context5.sent;\n              if (!(canProceed !== true)) {\n                _context5.next = 9;\n                break;\n              }\n              if (!(typeof canProceed === 'object')) {\n                _context5.next = 8;\n                break;\n              }\n              return _context5.abrupt(\"return\", canProceed.redirect);\n            case 8:\n              return _context5.abrupt(\"return\", false);\n            case 9:\n              return _context5.abrupt(\"return\", true);\n            case 10:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function canTransition() {\n        return _canTransition.apply(this, arguments);\n      }\n      return canTransition;\n    }()\n    /**\n     * Navigate to the specified path.\n     *\n     * @param path The path to navigate to.\n     * @param direction The direction of the animation. Defaults to `\"forward\"`.\n     */\n  }, {\n    key: \"push\",\n    value: function () {\n      var _push = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(path) {\n        var direction,\n          animation,\n          _a,\n          currentPath,\n          url,\n          parsedPath,\n          canProceed,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              direction = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 'forward';\n              animation = _args6.length > 2 ? _args6[2] : undefined;\n              if (path.startsWith('.')) {\n                currentPath = (_a = this.previousPath) !== null && _a !== void 0 ? _a : '/'; // Convert currentPath to an URL by pre-pending a protocol and a host to resolve the relative path.\n                url = new URL(path, \"https://host/\".concat(currentPath));\n                path = url.pathname + url.search;\n              }\n              parsedPath = parsePath(path);\n              _context6.next = 6;\n              return this.runGuards(parsedPath.segments);\n            case 6:\n              canProceed = _context6.sent;\n              if (!(canProceed !== true)) {\n                _context6.next = 13;\n                break;\n              }\n              if (!(typeof canProceed === 'object')) {\n                _context6.next = 12;\n                break;\n              }\n              parsedPath = parsePath(canProceed.redirect);\n              _context6.next = 13;\n              break;\n            case 12:\n              return _context6.abrupt(\"return\", false);\n            case 13:\n              this.setSegments(parsedPath.segments, direction, parsedPath.queryString);\n              return _context6.abrupt(\"return\", this.writeNavStateRoot(parsedPath.segments, direction, animation));\n            case 15:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function push(_x6) {\n        return _push.apply(this, arguments);\n      }\n      return push;\n    }() /** Go back to previous page in the window.history. */\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n      return Promise.resolve(this.waitPromise);\n    } /** @internal */\n  }, {\n    key: \"printDebug\",\n    value: function () {\n      var _printDebug = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              printRoutes(readRoutes(this.el));\n              printRedirects(readRedirects(this.el));\n            case 2:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function printDebug() {\n        return _printDebug.apply(this, arguments);\n      }\n      return printDebug;\n    }() /** @internal */\n  }, {\n    key: \"navChanged\",\n    value: function () {\n      var _navChanged = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(direction) {\n        var _yield$readNavState, ids, outlet, routes, chain, segments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!this.busy) {\n                _context8.next = 3;\n                break;\n              }\n              console.warn('[ion-router] router is busy, navChanged was cancelled');\n              return _context8.abrupt(\"return\", false);\n            case 3:\n              _context8.next = 5;\n              return readNavState(window.document.body);\n            case 5:\n              _yield$readNavState = _context8.sent;\n              ids = _yield$readNavState.ids;\n              outlet = _yield$readNavState.outlet;\n              routes = readRoutes(this.el);\n              chain = findChainForIDs(ids, routes);\n              if (chain) {\n                _context8.next = 13;\n                break;\n              }\n              console.warn('[ion-router] no matching URL for ', ids.map(function (i) {\n                return i.id;\n              }));\n              return _context8.abrupt(\"return\", false);\n            case 13:\n              segments = chainToSegments(chain);\n              if (segments) {\n                _context8.next = 17;\n                break;\n              }\n              console.warn('[ion-router] router could not match path because some required param is missing');\n              return _context8.abrupt(\"return\", false);\n            case 17:\n              this.setSegments(segments, direction);\n              _context8.next = 20;\n              return this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, segments, null, ids.length);\n            case 20:\n              return _context8.abrupt(\"return\", true);\n            case 21:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function navChanged(_x7) {\n        return _navChanged.apply(this, arguments);\n      }\n      return navChanged;\n    }() /** This handler gets called when a `ion-route-redirect` component is added to the DOM or if the from or to property of such node changes. */\n  }, {\n    key: \"onRedirectChanged\",\n    value: function onRedirectChanged() {\n      var segments = this.getSegments();\n      if (segments && findRouteRedirect(segments, readRedirects(this.el))) {\n        this.writeNavStateRoot(segments, ROUTER_INTENT_NONE);\n      }\n    } /** This handler gets called when a `ion-route` component is added to the DOM or if the from or to property of such node changes. */\n  }, {\n    key: \"onRoutesChanged\",\n    value: function onRoutesChanged() {\n      return this.writeNavStateRoot(this.getSegments(), ROUTER_INTENT_NONE);\n    }\n  }, {\n    key: \"historyDirection\",\n    value: function historyDirection() {\n      var _a;\n      var win = window;\n      if (win.history.state === null) {\n        this.state++;\n        win.history.replaceState(this.state, win.document.title, (_a = win.document.location) === null || _a === void 0 ? void 0 : _a.href);\n      }\n      var state = win.history.state;\n      var lastState = this.lastState;\n      this.lastState = state;\n      if (state > lastState || state >= lastState && lastState > 0) {\n        return ROUTER_INTENT_FORWARD;\n      }\n      if (state < lastState) {\n        return ROUTER_INTENT_BACK;\n      }\n      return ROUTER_INTENT_NONE;\n    }\n  }, {\n    key: \"writeNavStateRoot\",\n    value: function () {\n      var _writeNavStateRoot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(segments, direction, animation) {\n        var redirects, redirect, redirectFrom, _redirect$to, toSegments, queryString, routes, chain;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (segments) {\n                _context9.next = 3;\n                break;\n              }\n              console.error('[ion-router] URL is not part of the routing set');\n              return _context9.abrupt(\"return\", false);\n            case 3:\n              // lookup redirect rule\n              redirects = readRedirects(this.el);\n              redirect = findRouteRedirect(segments, redirects);\n              redirectFrom = null;\n              if (redirect) {\n                _redirect$to = redirect.to, toSegments = _redirect$to.segments, queryString = _redirect$to.queryString;\n                this.setSegments(toSegments, direction, queryString);\n                redirectFrom = redirect.from;\n                segments = toSegments;\n              }\n              // lookup route chain\n              routes = readRoutes(this.el);\n              chain = findChainForSegments(segments, routes);\n              if (chain) {\n                _context9.next = 12;\n                break;\n              }\n              console.error('[ion-router] the path does not match any route');\n              return _context9.abrupt(\"return\", false);\n            case 12:\n              return _context9.abrupt(\"return\", this.safeWriteNavState(document.body, chain, direction, segments, redirectFrom, 0, animation));\n            case 13:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function writeNavStateRoot(_x8, _x9, _x10) {\n        return _writeNavStateRoot.apply(this, arguments);\n      }\n      return writeNavStateRoot;\n    }()\n  }, {\n    key: \"safeWriteNavState\",\n    value: function () {\n      var _safeWriteNavState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(node, chain, direction, segments, redirectFrom) {\n        var index,\n          animation,\n          unlock,\n          changed,\n          _args10 = arguments;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              index = _args10.length > 5 && _args10[5] !== undefined ? _args10[5] : 0;\n              animation = _args10.length > 6 ? _args10[6] : undefined;\n              _context10.next = 4;\n              return this.lock();\n            case 4:\n              unlock = _context10.sent;\n              changed = false;\n              _context10.prev = 6;\n              _context10.next = 9;\n              return this.writeNavState(node, chain, direction, segments, redirectFrom, index, animation);\n            case 9:\n              changed = _context10.sent;\n              _context10.next = 15;\n              break;\n            case 12:\n              _context10.prev = 12;\n              _context10.t0 = _context10[\"catch\"](6);\n              console.error(_context10.t0);\n            case 15:\n              unlock();\n              return _context10.abrupt(\"return\", changed);\n            case 17:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[6, 12]]);\n      }));\n      function safeWriteNavState(_x11, _x12, _x13, _x14, _x15) {\n        return _safeWriteNavState.apply(this, arguments);\n      }\n      return safeWriteNavState;\n    }()\n  }, {\n    key: \"lock\",\n    value: function () {\n      var _lock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var p, resolve;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              p = this.waitPromise;\n              this.waitPromise = new Promise(function (r) {\n                return resolve = r;\n              });\n              if (!(p !== undefined)) {\n                _context11.next = 5;\n                break;\n              }\n              _context11.next = 5;\n              return p;\n            case 5:\n              return _context11.abrupt(\"return\", resolve);\n            case 6:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function lock() {\n        return _lock.apply(this, arguments);\n      }\n      return lock;\n    }()\n    /**\n     * Executes the beforeLeave hook of the source route and the beforeEnter hook of the target route if they exist.\n     *\n     * When the beforeLeave hook does not return true (to allow navigating) then that value is returned early and the beforeEnter is executed.\n     * Otherwise the beforeEnterHook hook of the target route is executed.\n     */\n  }, {\n    key: \"runGuards\",\n    value: function () {\n      var _runGuards = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var to,\n          from,\n          routes,\n          fromChain,\n          beforeLeaveHook,\n          canLeave,\n          toChain,\n          beforeEnterHook,\n          _args12 = arguments;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              to = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : this.getSegments();\n              from = _args12.length > 1 ? _args12[1] : undefined;\n              if (from === undefined) {\n                from = parsePath(this.previousPath).segments;\n              }\n              if (!(!to || !from)) {\n                _context12.next = 5;\n                break;\n              }\n              return _context12.abrupt(\"return\", true);\n            case 5:\n              routes = readRoutes(this.el);\n              fromChain = findChainForSegments(from, routes);\n              beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;\n              if (!beforeLeaveHook) {\n                _context12.next = 14;\n                break;\n              }\n              _context12.next = 11;\n              return beforeLeaveHook();\n            case 11:\n              _context12.t0 = _context12.sent;\n              _context12.next = 15;\n              break;\n            case 14:\n              _context12.t0 = true;\n            case 15:\n              canLeave = _context12.t0;\n              if (!(canLeave === false || typeof canLeave === 'object')) {\n                _context12.next = 18;\n                break;\n              }\n              return _context12.abrupt(\"return\", canLeave);\n            case 18:\n              toChain = findChainForSegments(to, routes);\n              beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;\n              return _context12.abrupt(\"return\", beforeEnterHook ? beforeEnterHook() : true);\n            case 21:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function runGuards() {\n        return _runGuards.apply(this, arguments);\n      }\n      return runGuards;\n    }()\n  }, {\n    key: \"writeNavState\",\n    value: function () {\n      var _writeNavState2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(node, chain, direction, segments, redirectFrom) {\n        var index,\n          animation,\n          routeEvent,\n          changed,\n          _args13 = arguments;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              index = _args13.length > 5 && _args13[5] !== undefined ? _args13[5] : 0;\n              animation = _args13.length > 6 ? _args13[6] : undefined;\n              if (!this.busy) {\n                _context13.next = 5;\n                break;\n              }\n              console.warn('[ion-router] router is busy, transition was cancelled');\n              return _context13.abrupt(\"return\", false);\n            case 5:\n              this.busy = true;\n              // generate route event and emit will change\n              routeEvent = this.routeChangeEvent(segments, redirectFrom);\n              if (routeEvent) {\n                this.ionRouteWillChange.emit(routeEvent);\n              }\n              _context13.next = 10;\n              return _writeNavState(node, chain, direction, index, false, animation);\n            case 10:\n              changed = _context13.sent;\n              this.busy = false;\n              // emit did change\n              if (routeEvent) {\n                this.ionRouteDidChange.emit(routeEvent);\n              }\n              return _context13.abrupt(\"return\", changed);\n            case 14:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function writeNavState(_x16, _x17, _x18, _x19, _x20) {\n        return _writeNavState2.apply(this, arguments);\n      }\n      return writeNavState;\n    }()\n  }, {\n    key: \"setSegments\",\n    value: function setSegments(segments, direction, queryString) {\n      this.state++;\n      writeSegments(window.history, this.root, this.useHash, segments, direction, this.state, queryString);\n    }\n  }, {\n    key: \"getSegments\",\n    value: function getSegments() {\n      return readSegments(window.location, this.root, this.useHash);\n    }\n  }, {\n    key: \"routeChangeEvent\",\n    value: function routeChangeEvent(toSegments, redirectFromSegments) {\n      var from = this.previousPath;\n      var to = generatePath(toSegments);\n      this.previousPath = to;\n      if (to === from) {\n        return null;\n      }\n      var redirectedFrom = redirectFromSegments ? generatePath(redirectFromSegments) : null;\n      return {\n        from: from,\n        redirectedFrom: redirectedFrom,\n        to: to\n      };\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return this;\n    }\n  }]);\n  return Router;\n}(HTMLElement), [0, \"ion-router\", {\n  \"root\": [1],\n  \"useHash\": [4, \"use-hash\"],\n  \"canTransition\": [64],\n  \"push\": [64],\n  \"back\": [64],\n  \"printDebug\": [64],\n  \"navChanged\": [64]\n}, [[8, \"popstate\", \"onPopState\"], [4, \"ionBackButton\", \"onBackButton\"]]]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  var components = [\"ion-router\"];\n  components.forEach(function (tagName) {\n    switch (tagName) {\n      case \"ion-router\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, Router);\n        }\n        break;\n    }\n  });\n}\nvar IonRouter = Router;\nvar defineCustomElement = defineCustomElement$1;\nexport { IonRouter, defineCustomElement };","map":null,"metadata":{},"sourceType":"module"}