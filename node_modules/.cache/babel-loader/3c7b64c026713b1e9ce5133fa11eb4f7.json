{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _asyncToGenerator from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Build } from '@stencil/core/internal/client';\nimport { b as getIonMode, c as config } from './ionic-global.js';\nimport { g as getTimeGivenProgression } from './cubic-bezier.js';\nimport { m as assert, s as shallowEqualStringMap } from './helpers.js';\nimport { l as lifecycle, t as _transition, s as setPageHidden, d as LIFECYCLE_WILL_UNLOAD, b as LIFECYCLE_WILL_LEAVE, c as LIFECYCLE_DID_LEAVE } from './index3.js';\nimport { a as attachComponent } from './framework-delegate.js';\nvar VIEW_STATE_NEW = 1;\nvar VIEW_STATE_ATTACHED = 2;\nvar VIEW_STATE_DESTROYED = 3;\n// TODO(FW-2832): types\nvar ViewController = /*#__PURE__*/function () {\n  function ViewController(component, params) {\n    _classCallCheck(this, ViewController);\n    this.component = component;\n    this.params = params;\n    this.state = VIEW_STATE_NEW;\n  }\n  _createClass(ViewController, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(container) {\n        var component;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.state = VIEW_STATE_ATTACHED;\n              if (this.element) {\n                _context.next = 6;\n                break;\n              }\n              component = this.component;\n              _context.next = 5;\n              return attachComponent(this.delegate, container, component, ['ion-page', 'ion-page-invisible'], this.params);\n            case 5:\n              this.element = _context.sent;\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n    /**\n     * DOM WRITE\n     */\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      assert(this.state !== VIEW_STATE_DESTROYED, 'view state must be ATTACHED');\n      var element = this.element;\n      if (element) {\n        if (this.delegate) {\n          this.delegate.removeViewFromDom(element.parentElement, element);\n        } else {\n          element.remove();\n        }\n      }\n      this.nav = undefined;\n      this.state = VIEW_STATE_DESTROYED;\n    }\n  }]);\n  return ViewController;\n}();\nvar matches = function matches(view, id, params) {\n  if (!view) {\n    return false;\n  }\n  if (view.component !== id) {\n    return false;\n  }\n  return shallowEqualStringMap(view.params, params);\n};\nvar convertToView = function convertToView(page, params) {\n  if (!page) {\n    return null;\n  }\n  if (page instanceof ViewController) {\n    return page;\n  }\n  return new ViewController(page, params);\n};\nvar convertToViews = function convertToViews(pages) {\n  return pages.map(function (page) {\n    if (page instanceof ViewController) {\n      return page;\n    }\n    if ('component' in page) {\n      return convertToView(page.component, page.componentProps === null ? undefined : page.componentProps);\n    }\n    return convertToView(page, undefined);\n  }).filter(function (v) {\n    return v !== null;\n  });\n};\nvar navCss = \":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}\";\nvar Nav = /*@__PURE__*/proxyCustomElement( /*#__PURE__*/function (_HTMLElement) {\n  _inherits(_class, _HTMLElement);\n  function _class() {\n    var _this;\n    _classCallCheck(this, _class);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));\n    _this.__registerHost();\n    _this.__attachShadow();\n    _this.ionNavWillLoad = createEvent(_assertThisInitialized(_assertThisInitialized(_this)), \"ionNavWillLoad\", 7);\n    _this.ionNavWillChange = createEvent(_assertThisInitialized(_assertThisInitialized(_this)), \"ionNavWillChange\", 3);\n    _this.ionNavDidChange = createEvent(_assertThisInitialized(_assertThisInitialized(_this)), \"ionNavDidChange\", 3);\n    _this.transInstr = [];\n    _this.animationEnabled = true;\n    _this.useRouter = false;\n    _this.isTransitioning = false;\n    _this.destroyed = false;\n    _this.views = [];\n    /**\n     * If `true`, the nav should animate the transition of components.\n     */\n    _this.animated = true;\n    return _this;\n  }\n  _createClass(_class, [{\n    key: \"swipeGestureChanged\",\n    value: function swipeGestureChanged() {\n      if (this.gesture) {\n        this.gesture.enable(this.swipeGesture === true);\n      }\n    }\n  }, {\n    key: \"rootChanged\",\n    value: function rootChanged() {\n      var isDev = Build.isDev;\n      if (this.root !== undefined) {\n        if (!this.useRouter) {\n          this.setRoot(this.root, this.rootParams);\n        } else if (isDev) {\n          console.warn('<ion-nav> does not support a root attribute when using ion-router.');\n        }\n      }\n    }\n  }, {\n    key: \"componentWillLoad\",\n    value: function componentWillLoad() {\n      this.useRouter = document.querySelector('ion-router') !== null && this.el.closest('[no-router]') === null;\n      if (this.swipeGesture === undefined) {\n        var mode = getIonMode(this);\n        this.swipeGesture = config.getBoolean('swipeBackEnabled', mode === 'ios');\n      }\n      this.ionNavWillLoad.emit();\n    }\n  }, {\n    key: \"componentDidLoad\",\n    value: function () {\n      var _componentDidLoad = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.rootChanged();\n              _context2.next = 3;\n              return import('./swipe-back.js');\n            case 3:\n              this.gesture = _context2.sent.createSwipeBackGesture(this.el, this.canStart.bind(this), this.onStart.bind(this), this.onMove.bind(this), this.onEnd.bind(this));\n              this.swipeGestureChanged();\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function componentDidLoad() {\n        return _componentDidLoad.apply(this, arguments);\n      }\n      return componentDidLoad;\n    }()\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      this.destroyed = false;\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      var _iterator = _createForOfIteratorHelper(this.views),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var view = _step.value;\n          lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);\n          view._destroy();\n        }\n        // Release swipe back gesture and transition.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (this.gesture) {\n        this.gesture.destroy();\n        this.gesture = undefined;\n      }\n      this.transInstr.length = 0;\n      this.views.length = 0;\n      this.destroyed = true;\n    }\n    /**\n     * Push a new component onto the current navigation stack. Pass any additional\n     * information along as an object. This additional information is accessible\n     * through NavParams.\n     *\n     * @param component The component to push onto the navigation stack.\n     * @param componentProps Any properties of the component.\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"push\",\n    value: function push(component, componentProps, opts, done) {\n      return this.insert(-1, component, componentProps, opts, done);\n    }\n    /**\n     * Inserts a component into the navigation stack at the specified index.\n     * This is useful to add a component at any point in the navigation stack.\n     *\n     * @param insertIndex The index to insert the component at in the stack.\n     * @param component The component to insert into the navigation stack.\n     * @param componentProps Any properties of the component.\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"insert\",\n    value: function insert(insertIndex, component, componentProps, opts, done) {\n      return this.insertPages(insertIndex, [{\n        component: component,\n        componentProps: componentProps\n      }], opts, done);\n    }\n    /**\n     * Inserts an array of components into the navigation stack at the specified index.\n     * The last component in the array will become instantiated as a view, and animate\n     * in to become the active view.\n     *\n     * @param insertIndex The index to insert the components at in the stack.\n     * @param insertComponents The components to insert into the navigation stack.\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"insertPages\",\n    value: function insertPages(insertIndex, insertComponents, opts, done) {\n      return this.queueTrns({\n        insertStart: insertIndex,\n        insertViews: insertComponents,\n        opts: opts\n      }, done);\n    }\n    /**\n     * Pop a component off of the navigation stack. Navigates back from the current\n     * component.\n     *\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"pop\",\n    value: function pop(opts, done) {\n      return this.removeIndex(-1, 1, opts, done);\n    }\n    /**\n     * Pop to a specific index in the navigation stack.\n     *\n     * @param indexOrViewCtrl The index or view controller to pop to.\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"popTo\",\n    value: function popTo(indexOrViewCtrl, opts, done) {\n      var ti = {\n        removeStart: -1,\n        removeCount: -1,\n        opts: opts\n      };\n      if (typeof indexOrViewCtrl === 'object' && indexOrViewCtrl.component) {\n        ti.removeView = indexOrViewCtrl;\n        ti.removeStart = 1;\n      } else if (typeof indexOrViewCtrl === 'number') {\n        ti.removeStart = indexOrViewCtrl + 1;\n      }\n      return this.queueTrns(ti, done);\n    }\n    /**\n     * Navigate back to the root of the stack, no matter how far back that is.\n     *\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"popToRoot\",\n    value: function popToRoot(opts, done) {\n      return this.removeIndex(1, -1, opts, done);\n    }\n    /**\n     * Removes a component from the navigation stack at the specified index.\n     *\n     * @param startIndex The number to begin removal at.\n     * @param removeCount The number of components to remove.\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"removeIndex\",\n    value: function removeIndex(startIndex) {\n      var removeCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var opts = arguments.length > 2 ? arguments[2] : undefined;\n      var done = arguments.length > 3 ? arguments[3] : undefined;\n      return this.queueTrns({\n        removeStart: startIndex,\n        removeCount: removeCount,\n        opts: opts\n      }, done);\n    }\n    /**\n     * Set the root for the current navigation stack to a component.\n     *\n     * @param component The component to set as the root of the navigation stack.\n     * @param componentProps Any properties of the component.\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"setRoot\",\n    value: function setRoot(component, componentProps, opts, done) {\n      return this.setPages([{\n        component: component,\n        componentProps: componentProps\n      }], opts, done);\n    }\n    /**\n     * Set the views of the current navigation stack and navigate to the last view.\n     * By default animations are disabled, but they can be enabled by passing options\n     * to the navigation controller. Navigation parameters can also be passed to the\n     * individual pages in the array.\n     *\n     * @param views The list of views to set as the navigation stack.\n     * @param opts The navigation options.\n     * @param done The transition complete function.\n     */\n  }, {\n    key: \"setPages\",\n    value: function setPages(views, opts, done) {\n      opts !== null && opts !== void 0 ? opts : opts = {};\n      // if animation wasn't set to true then default it to NOT animate\n      if (opts.animated !== true) {\n        opts.animated = false;\n      }\n      return this.queueTrns({\n        insertStart: 0,\n        insertViews: views,\n        removeStart: 0,\n        removeCount: -1,\n        opts: opts\n      }, done);\n    }\n    /**\n     * Called by the router to update the view.\n     *\n     * @param id The component tag.\n     * @param params The component params.\n     * @param direction A direction hint.\n     * @param animation an AnimationBuilder.\n     *\n     * @return the status.\n     * @internal\n     */\n  }, {\n    key: \"setRouteId\",\n    value: function setRouteId(id, params, direction, animation) {\n      var active = this.getActiveSync();\n      if (matches(active, id, params)) {\n        return Promise.resolve({\n          changed: false,\n          element: active.element\n        });\n      }\n      var resolve;\n      var promise = new Promise(function (r) {\n        return resolve = r;\n      });\n      var finish;\n      var commonOpts = {\n        updateURL: false,\n        viewIsReady: function viewIsReady(enteringEl) {\n          var mark;\n          var p = new Promise(function (r) {\n            return mark = r;\n          });\n          resolve({\n            changed: true,\n            element: enteringEl,\n            markVisible: function () {\n              var _markVisible = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      mark();\n                      _context3.next = 3;\n                      return finish;\n                    case 3:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _callee3);\n              }));\n              function markVisible() {\n                return _markVisible.apply(this, arguments);\n              }\n              return markVisible;\n            }()\n          });\n          return p;\n        }\n      };\n      if (direction === 'root') {\n        finish = this.setRoot(id, params, commonOpts);\n      } else {\n        // Look for a view matching the target in the view stack.\n        var viewController = this.views.find(function (v) {\n          return matches(v, id, params);\n        });\n        if (viewController) {\n          finish = this.popTo(viewController, Object.assign(Object.assign({}, commonOpts), {\n            direction: 'back',\n            animationBuilder: animation\n          }));\n        } else if (direction === 'forward') {\n          finish = this.push(id, params, Object.assign(Object.assign({}, commonOpts), {\n            animationBuilder: animation\n          }));\n        } else if (direction === 'back') {\n          finish = this.setRoot(id, params, Object.assign(Object.assign({}, commonOpts), {\n            direction: 'back',\n            animated: true,\n            animationBuilder: animation\n          }));\n        }\n      }\n      return promise;\n    }\n    /**\n     * Called by <ion-router> to retrieve the current component.\n     *\n     * @internal\n     */\n  }, {\n    key: \"getRouteId\",\n    value: function () {\n      var _getRouteId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var active;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              active = this.getActiveSync();\n              if (!active) {\n                _context4.next = 3;\n                break;\n              }\n              return _context4.abrupt(\"return\", {\n                id: active.element.tagName,\n                params: active.params,\n                element: active.element\n              });\n            case 3:\n              return _context4.abrupt(\"return\", undefined);\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function getRouteId() {\n        return _getRouteId.apply(this, arguments);\n      }\n      return getRouteId;\n    }()\n    /**\n     * Get the active view.\n     */\n  }, {\n    key: \"getActive\",\n    value: function () {\n      var _getActive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", this.getActiveSync());\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getActive() {\n        return _getActive.apply(this, arguments);\n      }\n      return getActive;\n    }()\n    /**\n     * Get the view at the specified index.\n     *\n     * @param index The index of the view.\n     */\n  }, {\n    key: \"getByIndex\",\n    value: function () {\n      var _getByIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(index) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", this.views[index]);\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getByIndex(_x2) {\n        return _getByIndex.apply(this, arguments);\n      }\n      return getByIndex;\n    }()\n    /**\n     * Returns `true` if the current view can go back.\n     *\n     * @param view The view to check.\n     */\n  }, {\n    key: \"canGoBack\",\n    value: function () {\n      var _canGoBack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(view) {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              return _context7.abrupt(\"return\", this.canGoBackSync(view));\n            case 1:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function canGoBack(_x3) {\n        return _canGoBack.apply(this, arguments);\n      }\n      return canGoBack;\n    }()\n    /**\n     * Get the previous view.\n     *\n     * @param view The view to get.\n     */\n  }, {\n    key: \"getPrevious\",\n    value: function () {\n      var _getPrevious = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(view) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              return _context8.abrupt(\"return\", this.getPreviousSync(view));\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function getPrevious(_x4) {\n        return _getPrevious.apply(this, arguments);\n      }\n      return getPrevious;\n    }()\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this.views.length;\n    }\n  }, {\n    key: \"getActiveSync\",\n    value: function getActiveSync() {\n      return this.views[this.views.length - 1];\n    }\n  }, {\n    key: \"canGoBackSync\",\n    value: function canGoBackSync() {\n      var view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getActiveSync();\n      return !!(view && this.getPreviousSync(view));\n    }\n  }, {\n    key: \"getPreviousSync\",\n    value: function getPreviousSync() {\n      var view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getActiveSync();\n      if (!view) {\n        return undefined;\n      }\n      var views = this.views;\n      var index = views.indexOf(view);\n      return index > 0 ? views[index - 1] : undefined;\n    }\n    /**\n     * Adds a navigation stack change to the queue and schedules it to run.\n     *\n     * @returns Whether the transition succeeds.\n     */\n  }, {\n    key: \"queueTrns\",\n    value: function () {\n      var _queueTrns = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(ti, done) {\n        var _a, _b, promise, router, canTransition;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (!(this.isTransitioning && ((_a = ti.opts) === null || _a === void 0 ? void 0 : _a.skipIfBusy))) {\n                _context9.next = 2;\n                break;\n              }\n              return _context9.abrupt(\"return\", false);\n            case 2:\n              promise = new Promise(function (resolve, reject) {\n                ti.resolve = resolve;\n                ti.reject = reject;\n              });\n              ti.done = done;\n              /**\n               * If using router, check to see if navigation hooks\n               * will allow us to perform this transition. This\n               * is required in order for hooks to work with\n               * the ion-back-button or swipe to go back.\n               */\n              if (!(ti.opts && ti.opts.updateURL !== false && this.useRouter)) {\n                _context9.next = 15;\n                break;\n              }\n              router = document.querySelector('ion-router');\n              if (!router) {\n                _context9.next = 15;\n                break;\n              }\n              _context9.next = 9;\n              return router.canTransition();\n            case 9:\n              canTransition = _context9.sent;\n              if (!(canTransition === false)) {\n                _context9.next = 12;\n                break;\n              }\n              return _context9.abrupt(\"return\", false);\n            case 12:\n              if (!(typeof canTransition === 'string')) {\n                _context9.next = 15;\n                break;\n              }\n              router.push(canTransition, ti.opts.direction || 'back');\n              return _context9.abrupt(\"return\", false);\n            case 15:\n              // Normalize empty\n              if (((_b = ti.insertViews) === null || _b === void 0 ? void 0 : _b.length) === 0) {\n                ti.insertViews = undefined;\n              }\n              // Enqueue transition instruction\n              this.transInstr.push(ti);\n              // if there isn't a transition already happening\n              // then this will kick off this transition\n              this.nextTrns();\n              return _context9.abrupt(\"return\", promise);\n            case 19:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function queueTrns(_x5, _x6) {\n        return _queueTrns.apply(this, arguments);\n      }\n      return queueTrns;\n    }()\n  }, {\n    key: \"success\",\n    value: function success(result, ti) {\n      if (this.destroyed) {\n        this.fireError('nav controller was destroyed', ti);\n        return;\n      }\n      if (ti.done) {\n        ti.done(result.hasCompleted, result.requiresTransition, result.enteringView, result.leavingView, result.direction);\n      }\n      ti.resolve(result.hasCompleted);\n      if (ti.opts.updateURL !== false && this.useRouter) {\n        var router = document.querySelector('ion-router');\n        if (router) {\n          var direction = result.direction === 'back' ? 'back' : 'forward';\n          router.navChanged(direction);\n        }\n      }\n    }\n  }, {\n    key: \"failed\",\n    value: function failed(rejectReason, ti) {\n      if (this.destroyed) {\n        this.fireError('nav controller was destroyed', ti);\n        return;\n      }\n      this.transInstr.length = 0;\n      this.fireError(rejectReason, ti);\n    }\n  }, {\n    key: \"fireError\",\n    value: function fireError(rejectReason, ti) {\n      if (ti.done) {\n        ti.done(false, false, rejectReason);\n      }\n      if (ti.reject && !this.destroyed) {\n        ti.reject(rejectReason);\n      } else {\n        ti.resolve(false);\n      }\n    }\n    /**\n     * Consumes the next transition in the queue.\n     *\n     * @returns whether the transition is executed.\n     */\n  }, {\n    key: \"nextTrns\",\n    value: function nextTrns() {\n      // this is the framework's bread 'n butta function\n      // only one transition is allowed at any given time\n      if (this.isTransitioning) {\n        return false;\n      }\n      // there is no transition happening right now, executes the next instructions.\n      var ti = this.transInstr.shift();\n      if (!ti) {\n        return false;\n      }\n      this.runTransition(ti);\n      return true;\n    } /** Executes all the transition instruction from the queue. */\n  }, {\n    key: \"runTransition\",\n    value: function () {\n      var _runTransition = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(ti) {\n        var leavingView, enteringView, requiresTransition, isBackDirection, result;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.prev = 0;\n              // set that this nav is actively transitioning\n              this.ionNavWillChange.emit();\n              this.isTransitioning = true;\n              this.prepareTI(ti);\n              leavingView = this.getActiveSync();\n              enteringView = this.getEnteringView(ti, leavingView);\n              if (!(!leavingView && !enteringView)) {\n                _context10.next = 8;\n                break;\n              }\n              throw new Error('no views in the stack to be removed');\n            case 8:\n              if (!(enteringView && enteringView.state === VIEW_STATE_NEW)) {\n                _context10.next = 11;\n                break;\n              }\n              _context10.next = 11;\n              return enteringView.init(this.el);\n            case 11:\n              this.postViewInit(enteringView, leavingView, ti);\n              // Needs transition?\n              requiresTransition = (ti.enteringRequiresTransition || ti.leavingRequiresTransition) && enteringView !== leavingView;\n              if (requiresTransition && ti.opts && leavingView) {\n                isBackDirection = ti.opts.direction === 'back';\n                /**\n                 * If heading back, use the entering page's animation\n                 * unless otherwise specified by the developer.\n                 */\n                if (isBackDirection) {\n                  ti.opts.animationBuilder = ti.opts.animationBuilder || (enteringView === null || enteringView === void 0 ? void 0 : enteringView.animationBuilder);\n                }\n                leavingView.animationBuilder = ti.opts.animationBuilder;\n              }\n              if (!requiresTransition) {\n                _context10.next = 20;\n                break;\n              }\n              _context10.next = 17;\n              return this.transition(enteringView, leavingView, ti);\n            case 17:\n              result = _context10.sent;\n              _context10.next = 21;\n              break;\n            case 20:\n              // transition is not required, so we are already done!\n              // they're inserting/removing the views somewhere in the middle or\n              // beginning, so visually nothing needs to animate/transition\n              // resolve immediately because there's no animation that's happening\n              result = {\n                hasCompleted: true,\n                requiresTransition: false\n              };\n            case 21:\n              this.success(result, ti);\n              this.ionNavDidChange.emit();\n              _context10.next = 28;\n              break;\n            case 25:\n              _context10.prev = 25;\n              _context10.t0 = _context10[\"catch\"](0);\n              this.failed(_context10.t0, ti);\n            case 28:\n              this.isTransitioning = false;\n              this.nextTrns();\n            case 30:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[0, 25]]);\n      }));\n      function runTransition(_x7) {\n        return _runTransition.apply(this, arguments);\n      }\n      return runTransition;\n    }()\n  }, {\n    key: \"prepareTI\",\n    value: function prepareTI(ti) {\n      var _a, _b;\n      var _c;\n      var viewsLength = this.views.length;\n      (_a = ti.opts) !== null && _a !== void 0 ? _a : ti.opts = {};\n      (_b = (_c = ti.opts).delegate) !== null && _b !== void 0 ? _b : _c.delegate = this.delegate;\n      if (ti.removeView !== undefined) {\n        assert(ti.removeStart !== undefined, 'removeView needs removeStart');\n        assert(ti.removeCount !== undefined, 'removeView needs removeCount');\n        var index = this.views.indexOf(ti.removeView);\n        if (index < 0) {\n          throw new Error('removeView was not found');\n        }\n        ti.removeStart += index;\n      }\n      if (ti.removeStart !== undefined) {\n        if (ti.removeStart < 0) {\n          ti.removeStart = viewsLength - 1;\n        }\n        if (ti.removeCount < 0) {\n          ti.removeCount = viewsLength - ti.removeStart;\n        }\n        ti.leavingRequiresTransition = ti.removeCount > 0 && ti.removeStart + ti.removeCount === viewsLength;\n      }\n      if (ti.insertViews) {\n        // allow -1 to be passed in to auto push it on the end\n        // and clean up the index if it's larger then the size of the stack\n        if (ti.insertStart < 0 || ti.insertStart > viewsLength) {\n          ti.insertStart = viewsLength;\n        }\n        ti.enteringRequiresTransition = ti.insertStart === viewsLength;\n      }\n      var insertViews = ti.insertViews;\n      if (!insertViews) {\n        return;\n      }\n      assert(insertViews.length > 0, 'length can not be zero');\n      var viewControllers = convertToViews(insertViews);\n      if (viewControllers.length === 0) {\n        throw new Error('invalid views to insert');\n      }\n      // Check all the inserted view are correct\n      var _iterator2 = _createForOfIteratorHelper(viewControllers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var view = _step2.value;\n          view.delegate = ti.opts.delegate;\n          var nav = view.nav;\n          if (nav && nav !== this) {\n            throw new Error('inserted view was already inserted');\n          }\n          if (view.state === VIEW_STATE_DESTROYED) {\n            throw new Error('inserted view was already destroyed');\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      ti.insertViews = viewControllers;\n    }\n    /**\n     * Returns the view that will be entered considering the transition instructions.\n     *\n     * @param ti The instructions.\n     * @param leavingView The view being left or undefined if none.\n     *\n     * @returns The view that will be entered, undefined if none.\n     */\n  }, {\n    key: \"getEnteringView\",\n    value: function getEnteringView(ti, leavingView) {\n      // The last inserted view will be entered when view are inserted.\n      var insertViews = ti.insertViews;\n      if (insertViews !== undefined) {\n        return insertViews[insertViews.length - 1];\n      }\n      // When views are deleted, we will enter the last view that is not removed and not the view being left.\n      var removeStart = ti.removeStart;\n      if (removeStart !== undefined) {\n        var views = this.views;\n        var removeEnd = removeStart + ti.removeCount;\n        for (var i = views.length - 1; i >= 0; i--) {\n          var view = views[i];\n          if ((i < removeStart || i >= removeEnd) && view !== leavingView) {\n            return view;\n          }\n        }\n      }\n      return undefined;\n    }\n    /**\n     * Adds and Removes the views from the navigation stack.\n     *\n     * @param enteringView The view being entered.\n     * @param leavingView The view being left.\n     * @param ti The instructions.\n     */\n  }, {\n    key: \"postViewInit\",\n    value: function postViewInit(enteringView, leavingView, ti) {\n      var _a, _b, _c;\n      assert(leavingView || enteringView, 'Both leavingView and enteringView are null');\n      assert(ti.resolve, 'resolve must be valid');\n      assert(ti.reject, 'reject must be valid');\n      // Compute the views to remove.\n      var opts = ti.opts;\n      var insertViews = ti.insertViews,\n        removeStart = ti.removeStart,\n        removeCount = ti.removeCount;\n      /** Records the view to destroy */\n      var destroyQueue;\n      // there are views to remove\n      if (removeStart !== undefined && removeCount !== undefined) {\n        assert(removeStart >= 0, 'removeStart can not be negative');\n        assert(removeCount >= 0, 'removeCount can not be negative');\n        destroyQueue = [];\n        for (var i = removeStart; i < removeStart + removeCount; i++) {\n          var view = this.views[i];\n          if (view !== undefined && view !== enteringView && view !== leavingView) {\n            destroyQueue.push(view);\n          }\n        }\n        // default the direction to \"back\"\n        (_a = opts.direction) !== null && _a !== void 0 ? _a : opts.direction = 'back';\n      }\n      var finalNumViews = this.views.length + ((_b = insertViews === null || insertViews === void 0 ? void 0 : insertViews.length) !== null && _b !== void 0 ? _b : 0) - (removeCount !== null && removeCount !== void 0 ? removeCount : 0);\n      assert(finalNumViews >= 0, 'final balance can not be negative');\n      if (finalNumViews === 0) {\n        console.warn(\"You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.\", this, this.el);\n        throw new Error('navigation stack needs at least one root page');\n      }\n      // At this point the transition can not be rejected, any throw should be an error\n      // Insert the new views in the stack.\n      if (insertViews) {\n        // add the views to the\n        var insertIndex = ti.insertStart;\n        var _iterator3 = _createForOfIteratorHelper(insertViews),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _view = _step3.value;\n            this.insertViewAt(_view, insertIndex);\n            insertIndex++;\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        if (ti.enteringRequiresTransition) {\n          // default to forward if not already set\n          (_c = opts.direction) !== null && _c !== void 0 ? _c : opts.direction = 'forward';\n        }\n      }\n      // if the views to be removed are in the beginning or middle\n      // and there is not a view that needs to visually transition out\n      // then just destroy them and don't transition anything\n      // batch all of lifecycles together\n      // let's make sure, callbacks are zoned\n      if (destroyQueue && destroyQueue.length > 0) {\n        var _iterator4 = _createForOfIteratorHelper(destroyQueue),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _view2 = _step4.value;\n            lifecycle(_view2.element, LIFECYCLE_WILL_LEAVE);\n            lifecycle(_view2.element, LIFECYCLE_DID_LEAVE);\n            lifecycle(_view2.element, LIFECYCLE_WILL_UNLOAD);\n          }\n          // once all lifecycle events has been delivered, we can safely detroy the views\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        var _iterator5 = _createForOfIteratorHelper(destroyQueue),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _view3 = _step5.value;\n            this.destroyView(_view3);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  }, {\n    key: \"transition\",\n    value: function () {\n      var _transition2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(enteringView, leavingView, ti) {\n        var _this2 = this;\n        var opts, progressCallback, mode, enteringEl, leavingEl, animationOpts, _yield$_transition, hasCompleted;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              // we should animate (duration > 0) if the pushed page is not the first one (startup)\n              // or if it is a portal (modal, actionsheet, etc.)\n              opts = ti.opts;\n              progressCallback = opts.progressAnimation ? function (ani) {\n                return _this2.sbAni = ani;\n              } : undefined;\n              mode = getIonMode(this);\n              enteringEl = enteringView.element;\n              leavingEl = leavingView && leavingView.element;\n              animationOpts = Object.assign(Object.assign({\n                mode: mode,\n                showGoBack: this.canGoBackSync(enteringView),\n                baseEl: this.el,\n                progressCallback: progressCallback,\n                animated: this.animated && config.getBoolean('animated', true),\n                enteringEl: enteringEl,\n                leavingEl: leavingEl\n              }, opts), {\n                animationBuilder: opts.animationBuilder || this.animation || config.get('navAnimation')\n              });\n              _context11.next = 8;\n              return _transition(animationOpts);\n            case 8:\n              _yield$_transition = _context11.sent;\n              hasCompleted = _yield$_transition.hasCompleted;\n              return _context11.abrupt(\"return\", this.transitionFinish(hasCompleted, enteringView, leavingView, opts));\n            case 11:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function transition(_x8, _x9, _x10) {\n        return _transition2.apply(this, arguments);\n      }\n      return transition;\n    }()\n  }, {\n    key: \"transitionFinish\",\n    value: function transitionFinish(hasCompleted, enteringView, leavingView, opts) {\n      /**\n       * If the transition did not complete, the leavingView will still be the active\n       * view on the stack. Otherwise unmount all the views after the enteringView.\n       */\n      var activeView = hasCompleted ? enteringView : leavingView;\n      if (activeView) {\n        this.unmountInactiveViews(activeView);\n      }\n      return {\n        hasCompleted: hasCompleted,\n        requiresTransition: true,\n        enteringView: enteringView,\n        leavingView: leavingView,\n        direction: opts.direction\n      };\n    }\n    /**\n     * Inserts a view at the specified index.\n     *\n     * When the view already is in the stack it will be moved to the new position.\n     *\n     * @param view The view to insert.\n     * @param index The index where to insert the view.\n     */\n  }, {\n    key: \"insertViewAt\",\n    value: function insertViewAt(view, index) {\n      var views = this.views;\n      var existingIndex = views.indexOf(view);\n      if (existingIndex > -1) {\n        assert(view.nav === this, 'view is not part of the nav');\n        // The view already in the stack, removes it.\n        views.splice(existingIndex, 1);\n        // and add it back at the requested index.\n        views.splice(index, 0, view);\n      } else {\n        assert(!view.nav, 'nav is used');\n        // this is a new view to add to the stack\n        // create the new entering view\n        view.nav = this;\n        views.splice(index, 0, view);\n      }\n    }\n    /**\n     * Removes a view from the stack.\n     *\n     * @param view The view to remove.\n     */\n  }, {\n    key: \"removeView\",\n    value: function removeView(view) {\n      assert(view.state === VIEW_STATE_ATTACHED || view.state === VIEW_STATE_DESTROYED, 'view state should be loaded or destroyed');\n      var views = this.views;\n      var index = views.indexOf(view);\n      assert(index > -1, 'view must be part of the stack');\n      if (index >= 0) {\n        views.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"destroyView\",\n    value: function destroyView(view) {\n      view._destroy();\n      this.removeView(view);\n    }\n    /**\n     * Unmounts all inactive views after the specified active view.\n     *\n     * DOM WRITE\n     *\n     * @param activeView The view that is actively visible in the stack. Used to calculate which views to unmount.\n     */\n  }, {\n    key: \"unmountInactiveViews\",\n    value: function unmountInactiveViews(activeView) {\n      // ok, cleanup time!! Destroy all of the views that are\n      // INACTIVE and come after the active view\n      // only do this if the views exist, though\n      if (this.destroyed) {\n        return;\n      }\n      var views = this.views;\n      var activeViewIndex = views.indexOf(activeView);\n      for (var i = views.length - 1; i >= 0; i--) {\n        var view = views[i];\n        /**\n         * When inserting multiple views via insertPages\n         * the last page will be transitioned to, but the\n         * others will not be. As a result, a DOM element\n         * will only be created for the last page inserted.\n         * As a result, it is possible to have views in the\n         * stack that do not have `view.element` yet.\n         */\n        var element = view.element;\n        if (element) {\n          if (i > activeViewIndex) {\n            // this view comes after the active view\n            // let's unload it\n            lifecycle(element, LIFECYCLE_WILL_UNLOAD);\n            this.destroyView(view);\n          } else if (i < activeViewIndex) {\n            // this view comes before the active view\n            // and it is not a portal then ensure it is hidden\n            setPageHidden(element, true);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"canStart\",\n    value: function canStart() {\n      return !!this.swipeGesture && !this.isTransitioning && this.transInstr.length === 0 && this.animationEnabled && this.canGoBackSync();\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart() {\n      this.pop({\n        direction: 'back',\n        progressAnimation: true\n      });\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(stepValue) {\n      if (this.sbAni) {\n        this.sbAni.progressStep(stepValue);\n      }\n    }\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(shouldComplete, stepValue, dur) {\n      var _this3 = this;\n      if (this.sbAni) {\n        this.animationEnabled = false;\n        this.sbAni.onFinish(function () {\n          _this3.animationEnabled = true;\n        }, {\n          oneTimeCallback: true\n        });\n        // Account for rounding errors in JS\n        var newStepValue = shouldComplete ? -0.001 : 0.001;\n        /**\n         * Animation will be reversed here, so need to\n         * reverse the easing curve as well\n         *\n         * Additionally, we need to account for the time relative\n         * to the new easing curve, as `stepValue` is going to be given\n         * in terms of a linear curve.\n         */\n        if (!shouldComplete) {\n          this.sbAni.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], stepValue)[0];\n        } else {\n          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], stepValue)[0];\n        }\n        this.sbAni.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return h(\"slot\", null);\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return this;\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"swipeGesture\": [\"swipeGestureChanged\"],\n        \"root\": [\"rootChanged\"]\n      };\n    }\n  }, {\n    key: \"style\",\n    get: function get() {\n      return navCss;\n    }\n  }]);\n  return _class;\n}(HTMLElement), [1, \"ion-nav\", {\n  \"delegate\": [16],\n  \"swipeGesture\": [1028, \"swipe-gesture\"],\n  \"animated\": [4],\n  \"animation\": [16],\n  \"rootParams\": [16],\n  \"root\": [1],\n  \"push\": [64],\n  \"insert\": [64],\n  \"insertPages\": [64],\n  \"pop\": [64],\n  \"popTo\": [64],\n  \"popToRoot\": [64],\n  \"removeIndex\": [64],\n  \"setRoot\": [64],\n  \"setPages\": [64],\n  \"setRouteId\": [64],\n  \"getRouteId\": [64],\n  \"getActive\": [64],\n  \"getByIndex\": [64],\n  \"canGoBack\": [64],\n  \"getPrevious\": [64]\n}]);\nfunction defineCustomElement$1() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  var components = [\"ion-nav\"];\n  components.forEach(function (tagName) {\n    switch (tagName) {\n      case \"ion-nav\":\n        if (!customElements.get(tagName)) {\n          customElements.define(tagName, Nav);\n        }\n        break;\n    }\n  });\n}\nvar IonNav = Nav;\nvar defineCustomElement = defineCustomElement$1;\nexport { IonNav, defineCustomElement };","map":null,"metadata":{},"sourceType":"module"}