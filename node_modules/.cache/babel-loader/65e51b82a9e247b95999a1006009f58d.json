{"ast":null,"code":"import _slicedToArray from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _assertThisInitialized from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nimport { __rest } from 'tslib';\nimport { createBrowserHistory, createHashHistory } from 'history';\nimport React from 'react';\nimport { matchPath as matchPath$1, withRouter, Router } from 'react-router-dom';\nimport { ViewStacks, generateId, IonRoute, ViewLifeCycleManager, StackContext, RouteManagerContext, getConfig, LocationHistory, NavManager } from '@ionic/react';\nimport { Route, matchPath, Router as Router$1 } from 'react-router';\nvar IonRouteInner = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(IonRouteInner, _React$PureComponent);\n  function IonRouteInner() {\n    _classCallCheck(this, IonRouteInner);\n    return _possibleConstructorReturn(this, _getPrototypeOf(IonRouteInner).apply(this, arguments));\n  }\n  _createClass(IonRouteInner, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(Route, {\n        path: this.props.path,\n        exact: this.props.exact,\n        render: this.props.render,\n        /**\n         * `computedMatch` is a private API in react-router v5 that\n         * has been removed in v6.\n         *\n         * This needs to be removed when we support v6.\n         *\n         * TODO: FW-647\n         */\n        computedMatch: this.props.computedMatch\n      });\n    }\n  }]);\n  return IonRouteInner;\n}(React.PureComponent);\nvar ReactRouterViewStack = /*#__PURE__*/function (_ViewStacks) {\n  _inherits(ReactRouterViewStack, _ViewStacks);\n  function ReactRouterViewStack() {\n    var _this;\n    _classCallCheck(this, ReactRouterViewStack);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactRouterViewStack).call(this));\n    _this.createViewItem = _this.createViewItem.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.findViewItemByRouteInfo = _this.findViewItemByRouteInfo.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.findLeavingViewItemByRouteInfo = _this.findLeavingViewItemByRouteInfo.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.getChildrenToRender = _this.getChildrenToRender.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.findViewItemByPathname = _this.findViewItemByPathname.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n  _createClass(ReactRouterViewStack, [{\n    key: \"createViewItem\",\n    value: function createViewItem(outletId, reactElement, routeInfo, page) {\n      var viewItem = {\n        id: generateId('viewItem'),\n        outletId: outletId,\n        ionPageElement: page,\n        reactElement: reactElement,\n        mount: true,\n        ionRoute: false\n      };\n      var matchProps = {\n        exact: reactElement.props.exact,\n        path: reactElement.props.path || reactElement.props.from,\n        component: reactElement.props.component\n      };\n      var match = matchPath(routeInfo.pathname, matchProps);\n      if (reactElement.type === IonRoute) {\n        viewItem.ionRoute = true;\n        viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n      }\n      viewItem.routeData = {\n        match: match,\n        childProps: reactElement.props\n      };\n      return viewItem;\n    }\n  }, {\n    key: \"getChildrenToRender\",\n    value: function getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {\n      var _this2 = this;\n      var viewItems = this.getViewItemsForOutlet(outletId);\n      // Sync latest routes with viewItems\n      React.Children.forEach(ionRouterOutlet.props.children, function (child) {\n        var viewItem = viewItems.find(function (v) {\n          return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);\n        });\n        if (viewItem) {\n          viewItem.reactElement = child;\n        }\n      });\n      var children = viewItems.map(function (viewItem) {\n        var clonedChild;\n        if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n          clonedChild = React.createElement(ViewLifeCycleManager, {\n            key: \"view-\".concat(viewItem.id),\n            mount: viewItem.mount,\n            removeView: function removeView() {\n              return _this2.remove(viewItem);\n            }\n          }, React.cloneElement(viewItem.reactElement, {\n            computedMatch: viewItem.routeData.match\n          }));\n        } else {\n          var match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);\n          clonedChild = React.createElement(ViewLifeCycleManager, {\n            key: \"view-\".concat(viewItem.id),\n            mount: viewItem.mount,\n            removeView: function removeView() {\n              return _this2.remove(viewItem);\n            }\n          }, React.cloneElement(viewItem.reactElement, {\n            computedMatch: viewItem.routeData.match\n          }));\n          if (!match && viewItem.routeData.match) {\n            viewItem.routeData.match = undefined;\n            viewItem.mount = false;\n          }\n        }\n        return clonedChild;\n      });\n      return children;\n    }\n  }, {\n    key: \"findViewItemByRouteInfo\",\n    value: function findViewItemByRouteInfo(routeInfo, outletId, updateMatch) {\n      var _this$findViewItemByP = this.findViewItemByPath(routeInfo.pathname, outletId),\n        viewItem = _this$findViewItemByP.viewItem,\n        match = _this$findViewItemByP.match;\n      var shouldUpdateMatch = updateMatch === undefined || updateMatch === true;\n      if (shouldUpdateMatch && viewItem && match) {\n        viewItem.routeData.match = match;\n      }\n      return viewItem;\n    }\n  }, {\n    key: \"findLeavingViewItemByRouteInfo\",\n    value: function findLeavingViewItemByRouteInfo(routeInfo, outletId) {\n      var mustBeIonRoute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var _this$findViewItemByP2 = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute),\n        viewItem = _this$findViewItemByP2.viewItem;\n      return viewItem;\n    }\n  }, {\n    key: \"findViewItemByPathname\",\n    value: function findViewItemByPathname(pathname, outletId) {\n      var _this$findViewItemByP3 = this.findViewItemByPath(pathname, outletId),\n        viewItem = _this$findViewItemByP3.viewItem;\n      return viewItem;\n    }\n  }, {\n    key: \"findViewItemByPath\",\n    value: function findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {\n      var viewItem;\n      var match;\n      var viewStack;\n      if (outletId) {\n        viewStack = this.getViewItemsForOutlet(outletId);\n        viewStack.some(matchView);\n        if (!viewItem) {\n          viewStack.some(matchDefaultRoute);\n        }\n      } else {\n        var viewItems = this.getAllViewItems();\n        viewItems.some(matchView);\n        if (!viewItem) {\n          viewItems.some(matchDefaultRoute);\n        }\n      }\n      return {\n        viewItem: viewItem,\n        match: match\n      };\n      function matchView(v) {\n        if (mustBeIonRoute && !v.ionRoute) {\n          return false;\n        }\n        var matchProps = {\n          exact: forceExact ? true : v.routeData.childProps.exact,\n          path: v.routeData.childProps.path || v.routeData.childProps.from,\n          component: v.routeData.childProps.component\n        };\n        var myMatch = matchPath(pathname, matchProps);\n        if (myMatch) {\n          viewItem = v;\n          match = myMatch;\n          return true;\n        }\n        return false;\n      }\n      function matchDefaultRoute(v) {\n        // try to find a route that doesn't have a path or from prop, that will be our default route\n        if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n          match = {\n            path: pathname,\n            url: pathname,\n            isExact: true,\n            params: {}\n          };\n          viewItem = v;\n          return true;\n        }\n        return false;\n      }\n    }\n  }]);\n  return ReactRouterViewStack;\n}(ViewStacks);\nfunction matchComponent$1(node, pathname, forceExact) {\n  var matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  var match = matchPath(pathname, matchProps);\n  return match;\n}\nfunction clonePageElement(leavingViewHtml) {\n  var html;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    var newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    var ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild;\n  }\n  return undefined;\n}\nvar isViewVisible = function isViewVisible(el) {\n  return !el.classList.contains('ion-page-invisible') && !el.classList.contains('ion-page-hidden');\n};\nvar StackManager = /*#__PURE__*/function (_React$PureComponent2) {\n  _inherits(StackManager, _React$PureComponent2);\n  function StackManager(props) {\n    var _this3;\n    _classCallCheck(this, StackManager);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(StackManager).call(this, props));\n    _this3.stackContextValue = {\n      registerIonPage: _this3.registerIonPage.bind(_assertThisInitialized(_assertThisInitialized(_this3))),\n      isInOutlet: function isInOutlet() {\n        return true;\n      }\n    };\n    _this3.pendingPageTransition = false;\n    _this3.registerIonPage = _this3.registerIonPage.bind(_assertThisInitialized(_assertThisInitialized(_this3)));\n    _this3.transitionPage = _this3.transitionPage.bind(_assertThisInitialized(_assertThisInitialized(_this3)));\n    _this3.handlePageTransition = _this3.handlePageTransition.bind(_assertThisInitialized(_assertThisInitialized(_this3)));\n    _this3.id = generateId('routerOutlet');\n    _this3.prevProps = undefined;\n    _this3.skipTransition = false;\n    return _this3;\n  }\n  _createClass(StackManager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.clearOutletTimeout) {\n        /**\n         * The clearOutlet integration with React Router is a bit hacky.\n         * It uses a timeout to clear the outlet after a transition.\n         * In React v18, components are mounted and unmounted in development mode\n         * to check for side effects.\n         *\n         * This clearTimeout prevents the outlet from being cleared when the component is re-mounted,\n         * which should only happen in development mode and as a result of a hot reload.\n         */\n        clearTimeout(this.clearOutletTimeout);\n      }\n      if (this.routerOutletElement) {\n        this.setupRouterOutlet(this.routerOutletElement);\n        this.handlePageTransition(this.props.routeInfo);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var pathname = this.props.routeInfo.pathname;\n      var prevPathname = prevProps.routeInfo.pathname;\n      if (pathname !== prevPathname) {\n        this.prevProps = prevProps;\n        this.handlePageTransition(this.props.routeInfo);\n      } else if (this.pendingPageTransition) {\n        this.handlePageTransition(this.props.routeInfo);\n        this.pendingPageTransition = false;\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearOutletTimeout = this.context.clearOutlet(this.id);\n    }\n  }, {\n    key: \"handlePageTransition\",\n    value: function () {\n      var _handlePageTransition = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(routeInfo) {\n        var _a, _b, enteringViewItem, leavingViewItem, enteringRoute;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this.routerOutletElement || !this.routerOutletElement.commit)) {\n                _context.next = 4;\n                break;\n              }\n              /**\n               * The route outlet has not mounted yet. We need to wait for it to render\n               * before we can transition the page.\n               *\n               * Set a flag to indicate that we should transition the page after\n               * the component has updated.\n               */\n              this.pendingPageTransition = true;\n              _context.next = 22;\n              break;\n            case 4:\n              enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n              leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n              if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n                leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n              }\n              // Check if leavingViewItem should be unmounted\n              if (leavingViewItem) {\n                if (routeInfo.routeAction === 'replace') {\n                  leavingViewItem.mount = false;\n                } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n                  if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n                    leavingViewItem.mount = false;\n                  }\n                } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {\n                  leavingViewItem.mount = false;\n                }\n              }\n              enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);\n              if (enteringViewItem) {\n                enteringViewItem.reactElement = enteringRoute;\n              } else if (enteringRoute) {\n                enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n                this.context.addViewItem(enteringViewItem);\n              }\n              if (!(enteringViewItem && enteringViewItem.ionPageElement)) {\n                _context.next = 20;\n                break;\n              }\n              if (!(enteringViewItem === leavingViewItem)) {\n                _context.next = 14;\n                break;\n              }\n              if (!(enteringViewItem.routeData.match.url !== routeInfo.pathname)) {\n                _context.next = 14;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 14:\n              /**\n               * If there isn't a leaving view item, but the route info indicates\n               * that the user has routed from a previous path, then we need\n               * to find the leaving view item to transition between.\n               */\n              if (!leavingViewItem && this.props.routeInfo.prevRouteLastPathname) {\n                leavingViewItem = this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname, this.id);\n              }\n              /**\n               * If the entering view is already visible and the leaving view is not, the transition does not need to occur.\n               */\n              if (!(isViewVisible(enteringViewItem.ionPageElement) && leavingViewItem !== undefined && !isViewVisible(leavingViewItem.ionPageElement))) {\n                _context.next = 17;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 17:\n              /**\n               * The view should only be transitioned in the following cases:\n               * 1. Performing a replace or pop action, such as a swipe to go back gesture\n               * to animation the leaving view off the screen.\n               *\n               * 2. Navigating between top-level router outlets, such as /page-1 to /page-2;\n               * or navigating within a nested outlet, such as /tabs/tab-1 to /tabs/tab-2.\n               *\n               * 3. The entering view is an ion-router-outlet containing a page\n               * matching the current route and that hasn't already transitioned in.\n               *\n               * This should only happen when navigating directly to a nested router outlet\n               * route or on an initial page load (i.e. refreshing). In cases when loading\n               * /tabs/tab-1, we need to transition the /tabs page element into the view.\n               */\n              this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n              _context.next = 21;\n              break;\n            case 20:\n              if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n                // If we have a leavingView but no entering view/route, we are probably leaving to\n                // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n                // transition to finish.\n                // setTimeout(() => {\n                if (leavingViewItem.ionPageElement) {\n                  leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n                  leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n                }\n                // }, 250);\n              }\n            case 21:\n              this.forceUpdate();\n            case 22:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function handlePageTransition(_x) {\n        return _handlePageTransition.apply(this, arguments);\n      }\n      return handlePageTransition;\n    }()\n  }, {\n    key: \"registerIonPage\",\n    value: function registerIonPage(page, routeInfo) {\n      var foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      if (foundView) {\n        var oldPageElement = foundView.ionPageElement;\n        foundView.ionPageElement = page;\n        foundView.ionRoute = true;\n        /**\n         * React 18 will unmount and remount IonPage\n         * elements in development mode when using createRoot.\n         * This can cause duplicate page transitions to occur.\n         */\n        if (oldPageElement === page) {\n          return;\n        }\n      }\n      this.handlePageTransition(routeInfo);\n    }\n  }, {\n    key: \"setupRouterOutlet\",\n    value: function () {\n      var _setupRouterOutlet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(routerOutlet) {\n        var _this4 = this;\n        var canStart, onStart, onEnd;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              canStart = function canStart() {\n                var config = getConfig();\n                var swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n                if (!swipeEnabled) {\n                  return false;\n                }\n                var routeInfo = _this4.props.routeInfo;\n                var propsToUse = _this4.prevProps && _this4.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? _this4.prevProps.routeInfo : {\n                  pathname: routeInfo.pushedByRoute || ''\n                };\n                var enteringViewItem = _this4.context.findViewItemByRouteInfo(propsToUse, _this4.id, false);\n                return !!enteringViewItem &&\n                /**\n                 * The root url '/' is treated as\n                 * the first view item (but is never mounted),\n                 * so we do not want to swipe back to the\n                 * root url.\n                 */\n                enteringViewItem.mount &&\n                /**\n                 * When on the first page (whatever view\n                 * you land on after the root url) it\n                 * is possible for findViewItemByRouteInfo to\n                 * return the exact same view you are currently on.\n                 * Make sure that we are not swiping back to the same\n                 * instances of a view.\n                 */\n                enteringViewItem.routeData.match.path !== routeInfo.pathname;\n              };\n              onStart = /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                  var routeInfo, propsToUse, enteringViewItem, leavingViewItem;\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        routeInfo = _this4.props.routeInfo;\n                        propsToUse = _this4.prevProps && _this4.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? _this4.prevProps.routeInfo : {\n                          pathname: routeInfo.pushedByRoute || ''\n                        };\n                        enteringViewItem = _this4.context.findViewItemByRouteInfo(propsToUse, _this4.id, false);\n                        leavingViewItem = _this4.context.findViewItemByRouteInfo(routeInfo, _this4.id, false);\n                        /**\n                         * When the gesture starts, kick off\n                         * a transition that is controlled\n                         * via a swipe gesture.\n                         */\n                        if (!(enteringViewItem && leavingViewItem)) {\n                          _context2.next = 7;\n                          break;\n                        }\n                        _context2.next = 7;\n                        return _this4.transitionPage(routeInfo, enteringViewItem, leavingViewItem, 'back', true);\n                      case 7:\n                        return _context2.abrupt(\"return\", Promise.resolve());\n                      case 8:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, _callee2);\n                }));\n                return function onStart() {\n                  return _ref.apply(this, arguments);\n                };\n              }();\n              onEnd = function onEnd(shouldContinue) {\n                if (shouldContinue) {\n                  _this4.skipTransition = true;\n                  _this4.context.goBack();\n                } else {\n                  /**\n                   * In the event that the swipe\n                   * gesture was aborted, we should\n                   * re-hide the page that was going to enter.\n                   */\n                  var routeInfo = _this4.props.routeInfo;\n                  var propsToUse = _this4.prevProps && _this4.prevProps.routeInfo.pathname === routeInfo.pushedByRoute ? _this4.prevProps.routeInfo : {\n                    pathname: routeInfo.pushedByRoute || ''\n                  };\n                  var enteringViewItem = _this4.context.findViewItemByRouteInfo(propsToUse, _this4.id, false);\n                  var leavingViewItem = _this4.context.findViewItemByRouteInfo(routeInfo, _this4.id, false);\n                  /**\n                   * Ionic React has a design defect where it\n                   * a) Unmounts the leaving view item when using parameterized routes\n                   * b) Considers the current view to be the entering view when using\n                   * parameterized routes\n                   *\n                   * As a result, we should not hide the view item here\n                   * as it will cause the current view to be hidden.\n                   */\n                  if (enteringViewItem !== leavingViewItem && (enteringViewItem === null || enteringViewItem === void 0 ? void 0 : enteringViewItem.ionPageElement) !== undefined) {\n                    var ionPageElement = enteringViewItem.ionPageElement;\n                    ionPageElement.setAttribute('aria-hidden', 'true');\n                    ionPageElement.classList.add('ion-page-hidden');\n                  }\n                }\n              };\n              routerOutlet.swipeHandler = {\n                canStart: canStart,\n                onStart: onStart,\n                onEnd: onEnd\n              };\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function setupRouterOutlet(_x2) {\n        return _setupRouterOutlet.apply(this, arguments);\n      }\n      return setupRouterOutlet;\n    }()\n  }, {\n    key: \"transitionPage\",\n    value: function () {\n      var _transitionPage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(routeInfo, enteringViewItem, leavingViewItem, direction) {\n        var _this5 = this;\n        var progressAnimation,\n          runCommit,\n          routerOutlet,\n          routeInfoFallbackDirection,\n          directionToUse,\n          match,\n          newLeavingElement,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              progressAnimation = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : false;\n              runCommit = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(enteringEl, leavingEl) {\n                  var skipTransition;\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        skipTransition = _this5.skipTransition;\n                        /**\n                         * If the transition was handled\n                         * via the swipe to go back gesture,\n                         * then we do not want to perform\n                         * another transition.\n                         *\n                         * We skip adding ion-page or ion-page-invisible\n                         * because the entering view already exists in the DOM.\n                         * If we added the classes, there would be a flicker where\n                         * the view would be briefly hidden.\n                         */\n                        if (skipTransition) {\n                          /**\n                           * We need to reset skipTransition before\n                           * we call routerOutlet.commit otherwise\n                           * the transition triggered by the swipe\n                           * to go back gesture would reset it. In\n                           * that case you would see a duplicate\n                           * transition triggered by handlePageTransition\n                           * in componentDidUpdate.\n                           */\n                          _this5.skipTransition = false;\n                        } else {\n                          enteringEl.classList.add('ion-page');\n                          enteringEl.classList.add('ion-page-invisible');\n                        }\n                        _context4.next = 4;\n                        return routerOutlet.commit(enteringEl, leavingEl, {\n                          deepWait: true,\n                          duration: skipTransition || directionToUse === undefined ? 0 : undefined,\n                          direction: directionToUse,\n                          showGoBack: !!routeInfo.pushedByRoute,\n                          progressAnimation: progressAnimation,\n                          animationBuilder: routeInfo.routeAnimation\n                        });\n                      case 4:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee4);\n                }));\n                return function runCommit(_x7, _x8) {\n                  return _ref2.apply(this, arguments);\n                };\n              }();\n              routerOutlet = this.routerOutletElement;\n              routeInfoFallbackDirection = routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n              directionToUse = direction !== null && direction !== void 0 ? direction : routeInfoFallbackDirection;\n              if (!(enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement)) {\n                _context5.next = 24;\n                break;\n              }\n              if (!(leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem)) {\n                _context5.next = 21;\n                break;\n              }\n              // If a page is transitioning to another version of itself\n              // we clone it so we can have an animation to show\n              match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n              if (!match) {\n                _context5.next = 17;\n                break;\n              }\n              newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n              if (!newLeavingElement) {\n                _context5.next = 15;\n                break;\n              }\n              this.routerOutletElement.appendChild(newLeavingElement);\n              _context5.next = 14;\n              return runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            case 14:\n              this.routerOutletElement.removeChild(newLeavingElement);\n            case 15:\n              _context5.next = 19;\n              break;\n            case 17:\n              _context5.next = 19;\n              return runCommit(enteringViewItem.ionPageElement, undefined);\n            case 19:\n              _context5.next = 24;\n              break;\n            case 21:\n              _context5.next = 23;\n              return runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);\n            case 23:\n              if (leavingViewItem && leavingViewItem.ionPageElement && !progressAnimation) {\n                leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n                leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n              }\n            case 24:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function transitionPage(_x3, _x4, _x5, _x6) {\n        return _transitionPage.apply(this, arguments);\n      }\n      return transitionPage;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n      var children = this.props.children;\n      var ionRouterOutlet = React.Children.only(children);\n      this.ionRouterOutlet = ionRouterOutlet;\n      var components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, function () {\n        _this6.forceUpdate();\n      });\n      return React.createElement(StackContext.Provider, {\n        value: this.stackContextValue\n      }, React.cloneElement(ionRouterOutlet, {\n        ref: function ref(node) {\n          if (ionRouterOutlet.props.setRef) {\n            ionRouterOutlet.props.setRef(node);\n          }\n          if (ionRouterOutlet.props.forwardedRef) {\n            ionRouterOutlet.props.forwardedRef.current = node;\n          }\n          _this6.routerOutletElement = node;\n          var ref = ionRouterOutlet.ref;\n          if (typeof ref === 'function') {\n            ref(node);\n          }\n        }\n      }, components));\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return RouteManagerContext;\n    }\n  }]);\n  return StackManager;\n}(React.PureComponent);\nfunction matchRoute(node, routeInfo) {\n  var matchedNode;\n  React.Children.forEach(node, function (child) {\n    var matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component\n    };\n    var match = matchPath$1(routeInfo.pathname, matchProps);\n    if (match) {\n      matchedNode = child;\n    }\n  });\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node, function (child) {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n  return matchedNode;\n}\nfunction matchComponent(node, pathname, forceExact) {\n  var matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  var match = matchPath$1(pathname, matchProps);\n  return match;\n}\nvar IonRouterInner = /*#__PURE__*/function (_React$PureComponent3) {\n  _inherits(IonRouterInner, _React$PureComponent3);\n  function IonRouterInner(props) {\n    var _this7;\n    _classCallCheck(this, IonRouterInner);\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(IonRouterInner).call(this, props));\n    _this7.exitViewFromOtherOutletHandlers = [];\n    _this7.locationHistory = new LocationHistory();\n    _this7.viewStack = new ReactRouterViewStack();\n    _this7.routeMangerContextState = {\n      canGoBack: function canGoBack() {\n        return _this7.locationHistory.canGoBack();\n      },\n      clearOutlet: _this7.viewStack.clear,\n      findViewItemByPathname: _this7.viewStack.findViewItemByPathname,\n      getChildrenToRender: _this7.viewStack.getChildrenToRender,\n      goBack: function goBack() {\n        return _this7.handleNavigateBack();\n      },\n      createViewItem: _this7.viewStack.createViewItem,\n      findViewItemByRouteInfo: _this7.viewStack.findViewItemByRouteInfo,\n      findLeavingViewItemByRouteInfo: _this7.viewStack.findLeavingViewItemByRouteInfo,\n      addViewItem: _this7.viewStack.add,\n      unMountViewItem: _this7.viewStack.remove\n    };\n    var routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: _this7.props.location.pathname,\n      search: _this7.props.location.search\n    };\n    _this7.locationHistory.add(routeInfo);\n    _this7.handleChangeTab = _this7.handleChangeTab.bind(_assertThisInitialized(_assertThisInitialized(_this7)));\n    _this7.handleResetTab = _this7.handleResetTab.bind(_assertThisInitialized(_assertThisInitialized(_this7)));\n    _this7.handleNativeBack = _this7.handleNativeBack.bind(_assertThisInitialized(_assertThisInitialized(_this7)));\n    _this7.handleNavigate = _this7.handleNavigate.bind(_assertThisInitialized(_assertThisInitialized(_this7)));\n    _this7.handleNavigateBack = _this7.handleNavigateBack.bind(_assertThisInitialized(_assertThisInitialized(_this7)));\n    _this7.props.registerHistoryListener(_this7.handleHistoryChange.bind(_assertThisInitialized(_assertThisInitialized(_this7))));\n    _this7.handleSetCurrentTab = _this7.handleSetCurrentTab.bind(_assertThisInitialized(_assertThisInitialized(_this7)));\n    _this7.state = {\n      routeInfo: routeInfo\n    };\n    return _this7;\n  }\n  _createClass(IonRouterInner, [{\n    key: \"handleChangeTab\",\n    value: function handleChangeTab(tab, path, routeOptions) {\n      if (!path) {\n        return;\n      }\n      var routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n      var _path$split = path.split('?'),\n        _path$split2 = _slicedToArray(_path$split, 2),\n        pathname = _path$split2[0],\n        search = _path$split2[1];\n      if (routeInfo) {\n        this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), {\n          routeAction: 'push',\n          routeDirection: 'none'\n        });\n        if (routeInfo.pathname === pathname) {\n          this.incomingRouteParams.routeOptions = routeOptions;\n          this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n        } else {\n          this.incomingRouteParams.pathname = pathname;\n          this.incomingRouteParams.search = search ? '?' + search : undefined;\n          this.incomingRouteParams.routeOptions = routeOptions;\n          this.props.history.push(pathname + (search ? '?' + search : ''));\n        }\n      } else {\n        this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n      }\n    }\n  }, {\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var _a, _b, _c;\n      var leavingLocationInfo;\n      if (this.incomingRouteParams) {\n        if (this.incomingRouteParams.routeAction === 'replace') {\n          leavingLocationInfo = this.locationHistory.previous();\n        } else {\n          leavingLocationInfo = this.locationHistory.current();\n        }\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n      var leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n      if (leavingUrl !== location.pathname) {\n        if (!this.incomingRouteParams) {\n          if (action === 'REPLACE') {\n            this.incomingRouteParams = {\n              routeAction: 'replace',\n              routeDirection: 'none',\n              tab: this.currentTab\n            };\n          }\n          if (action === 'POP') {\n            var currentRoute = this.locationHistory.current();\n            if (currentRoute && currentRoute.pushedByRoute) {\n              var prevInfo = this.locationHistory.findLastLocation(currentRoute);\n              this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n                routeAction: 'pop',\n                routeDirection: 'back'\n              });\n            } else {\n              this.incomingRouteParams = {\n                routeAction: 'pop',\n                routeDirection: 'none',\n                tab: this.currentTab\n              };\n            }\n          }\n          if (!this.incomingRouteParams) {\n            this.incomingRouteParams = {\n              routeAction: 'push',\n              routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || 'forward',\n              routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,\n              tab: this.currentTab\n            };\n          }\n        }\n        var routeInfo;\n        if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {\n          routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), {\n            lastPathname: leavingLocationInfo.pathname\n          });\n          this.locationHistory.add(routeInfo);\n        } else {\n          var isPushed = this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n          routeInfo = Object.assign(Object.assign({\n            id: generateId('routeInfo')\n          }, this.incomingRouteParams), {\n            lastPathname: leavingLocationInfo.pathname,\n            pathname: location.pathname,\n            search: location.search,\n            params: this.props.match.params,\n            prevRouteLastPathname: leavingLocationInfo.lastPathname\n          });\n          if (isPushed) {\n            routeInfo.tab = leavingLocationInfo.tab;\n            routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n          } else if (routeInfo.routeAction === 'pop') {\n            var r = this.locationHistory.findLastLocation(routeInfo);\n            routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;\n          } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n            // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n            var lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n            routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n          } else if (routeInfo.routeAction === 'replace') {\n            // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n            var currentRouteInfo = this.locationHistory.current();\n            /**\n             * If going from /home to /child, then replacing from\n             * /child to /home, we don't want the route info to\n             * say that /home was pushed by /home which is not correct.\n             */\n            var currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n            var pushedByRoute = currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;\n            routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n            routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n            routeInfo.pushedByRoute = pushedByRoute;\n            routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;\n            routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;\n          }\n          this.locationHistory.add(routeInfo);\n        }\n        this.setState({\n          routeInfo: routeInfo\n        });\n      }\n      this.incomingRouteParams = undefined;\n    }\n    /**\n     * history@4.x uses goBack(), history@5.x uses back()\n     * TODO: If support for React Router <=5 is dropped\n     * this logic is no longer needed. We can just\n     * assume back() is available.\n     */\n  }, {\n    key: \"handleNativeBack\",\n    value: function handleNativeBack() {\n      var history = this.props.history;\n      var goBack = history.goBack || history.back;\n      goBack();\n    }\n  }, {\n    key: \"handleNavigate\",\n    value: function handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {\n      this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n        routeAction: routeAction,\n        routeDirection: routeDirection,\n        routeOptions: routeOptions,\n        routeAnimation: routeAnimation,\n        tab: tab\n      });\n      if (routeAction === 'push') {\n        this.props.history.push(path);\n      } else {\n        this.props.history.replace(path);\n      }\n    }\n  }, {\n    key: \"handleNavigateBack\",\n    value: function handleNavigateBack() {\n      var defaultHref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n      var routeAnimation = arguments.length > 1 ? arguments[1] : undefined;\n      var config = getConfig();\n      defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref');\n      var routeInfo = this.locationHistory.current();\n      if (routeInfo && routeInfo.pushedByRoute) {\n        var prevInfo = this.locationHistory.findLastLocation(routeInfo);\n        if (prevInfo) {\n          this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n            routeAction: 'pop',\n            routeDirection: 'back',\n            routeAnimation: routeAnimation || routeInfo.routeAnimation\n          });\n          if (routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          /**\n           * We need to exclude tab switches/tab\n           * context changes here because tabbed\n           * navigation is not linear, but router.back()\n           * will go back in a linear fashion.\n           */\n          prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '') {\n            /**\n             * history@4.x uses goBack(), history@5.x uses back()\n             * TODO: If support for React Router <=5 is dropped\n             * this logic is no longer needed. We can just\n             * assume back() is available.\n             */\n            var history = this.props.history;\n            var goBack = history.goBack || history.back;\n            goBack();\n          } else {\n            this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n          }\n        } else {\n          this.handleNavigate(defaultHref, 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref, 'pop', 'back');\n      }\n    }\n  }, {\n    key: \"handleResetTab\",\n    value: function handleResetTab(tab, originalHref, originalRouteOptions) {\n      var routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n      if (routeInfo) {\n        var newRouteInfo = Object.assign({}, routeInfo);\n        newRouteInfo.pathname = originalHref;\n        newRouteInfo.routeOptions = originalRouteOptions;\n        this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), {\n          routeAction: 'pop',\n          routeDirection: 'back'\n        });\n        this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n      }\n    }\n  }, {\n    key: \"handleSetCurrentTab\",\n    value: function handleSetCurrentTab(tab) {\n      this.currentTab = tab;\n      var ri = Object.assign({}, this.locationHistory.current());\n      if (ri.tab !== tab) {\n        ri.tab = tab;\n        this.locationHistory.update(ri);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(RouteManagerContext.Provider, {\n        value: this.routeMangerContextState\n      }, React.createElement(NavManager, {\n        ionRoute: IonRouteInner,\n        ionRedirect: {},\n        stackManager: StackManager,\n        routeInfo: this.state.routeInfo,\n        onNativeBack: this.handleNativeBack,\n        onNavigateBack: this.handleNavigateBack,\n        onNavigate: this.handleNavigate,\n        onSetCurrentTab: this.handleSetCurrentTab,\n        onChangeTab: this.handleChangeTab,\n        onResetTab: this.handleResetTab,\n        locationHistory: this.locationHistory\n      }, this.props.children));\n    }\n  }]);\n  return IonRouterInner;\n}(React.PureComponent);\nvar IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\nvar IonReactRouter = /*#__PURE__*/function (_React$Component) {\n  _inherits(IonReactRouter, _React$Component);\n  function IonReactRouter(props) {\n    var _this8;\n    _classCallCheck(this, IonReactRouter);\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(IonReactRouter).call(this, props));\n    var history = props.history,\n      rest = __rest(props, [\"history\"]);\n    _this8.history = history || createBrowserHistory(rest);\n    _this8.history.listen(_this8.handleHistoryChange.bind(_assertThisInitialized(_assertThisInitialized(_this8))));\n    _this8.registerHistoryListener = _this8.registerHistoryListener.bind(_assertThisInitialized(_assertThisInitialized(_this8)));\n    return _this8;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  _createClass(IonReactRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n        children = _a.children,\n        props = __rest(_a, [\"children\"]);\n      return React.createElement(Router, Object.assign({\n        history: this.history\n      }, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n  return IonReactRouter;\n}(React.Component);\nvar IonReactMemoryRouter = /*#__PURE__*/function (_React$Component2) {\n  _inherits(IonReactMemoryRouter, _React$Component2);\n  function IonReactMemoryRouter(props) {\n    var _this9;\n    _classCallCheck(this, IonReactMemoryRouter);\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(IonReactMemoryRouter).call(this, props));\n    _this9.history = props.history;\n    _this9.history.listen(_this9.handleHistoryChange.bind(_assertThisInitialized(_assertThisInitialized(_this9))));\n    _this9.registerHistoryListener = _this9.registerHistoryListener.bind(_assertThisInitialized(_assertThisInitialized(_this9)));\n    return _this9;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  _createClass(IonReactMemoryRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n        children = _a.children,\n        props = __rest(_a, [\"children\"]);\n      return React.createElement(Router$1, Object.assign({}, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n  return IonReactMemoryRouter;\n}(React.Component);\nvar IonReactHashRouter = /*#__PURE__*/function (_React$Component3) {\n  _inherits(IonReactHashRouter, _React$Component3);\n  function IonReactHashRouter(props) {\n    var _this10;\n    _classCallCheck(this, IonReactHashRouter);\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(IonReactHashRouter).call(this, props));\n    var history = props.history,\n      rest = __rest(props, [\"history\"]);\n    _this10.history = history || createHashHistory(rest);\n    _this10.history.listen(_this10.handleHistoryChange.bind(_assertThisInitialized(_assertThisInitialized(_this10))));\n    _this10.registerHistoryListener = _this10.registerHistoryListener.bind(_assertThisInitialized(_assertThisInitialized(_this10)));\n    return _this10;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  _createClass(IonReactHashRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n        children = _a.children,\n        props = __rest(_a, [\"children\"]);\n      return React.createElement(Router, Object.assign({\n        history: this.history\n      }, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n  return IonReactHashRouter;\n}(React.Component);\nexport { IonReactHashRouter, IonReactMemoryRouter, IonReactRouter };","map":null,"metadata":{},"sourceType":"module"}