{"ast":null,"code":"import _toConsumableArray from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _assertThisInitialized from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _possibleConstructorReturn from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mvp/Documents/Projects/pure-weather-capacitor---v2.0.0/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nimport React, { useContext, useRef, useEffect, createElement, useState, Fragment, useMemo, useCallback } from 'react';\nimport { isPlatform as isPlatform$1, getPlatforms as getPlatforms$1, alertController, loadingController, toastController as toastController$1, pickerController, actionSheetController as actionSheetController$1, componentOnReady, createAnimation, modalController, popoverController, initialize } from '@ionic/core/components';\nexport { IonicSafeString, IonicSlides, IonicSwiper, createAnimation, createGesture, getTimeGivenProgression, iosTransitionAnimation, mdTransitionAnimation } from '@ionic/core/components';\nimport { __rest } from 'tslib';\nimport ReactDOM from 'react-dom';\nimport { defineCustomElement as defineCustomElement$1 } from '@ionic/core/components/ion-accordion.js';\nimport { defineCustomElement as defineCustomElement$2 } from '@ionic/core/components/ion-accordion-group.js';\nimport { defineCustomElement as defineCustomElement$3 } from '@ionic/core/components/ion-avatar.js';\nimport { defineCustomElement as defineCustomElement$4 } from '@ionic/core/components/ion-backdrop.js';\nimport { defineCustomElement as defineCustomElement$5 } from '@ionic/core/components/ion-badge.js';\nimport { defineCustomElement as defineCustomElement$6 } from '@ionic/core/components/ion-breadcrumbs.js';\nimport { defineCustomElement as defineCustomElement$7 } from '@ionic/core/components/ion-buttons.js';\nimport { defineCustomElement as defineCustomElement$8 } from '@ionic/core/components/ion-card-content.js';\nimport { defineCustomElement as defineCustomElement$9 } from '@ionic/core/components/ion-card-header.js';\nimport { defineCustomElement as defineCustomElement$a } from '@ionic/core/components/ion-card-subtitle.js';\nimport { defineCustomElement as defineCustomElement$b } from '@ionic/core/components/ion-card-title.js';\nimport { defineCustomElement as defineCustomElement$c } from '@ionic/core/components/ion-checkbox.js';\nimport { defineCustomElement as defineCustomElement$d } from '@ionic/core/components/ion-chip.js';\nimport { defineCustomElement as defineCustomElement$e } from '@ionic/core/components/ion-col.js';\nimport { defineCustomElement as defineCustomElement$f } from '@ionic/core/components/ion-content.js';\nimport { defineCustomElement as defineCustomElement$g } from '@ionic/core/components/ion-datetime.js';\nimport { defineCustomElement as defineCustomElement$h } from '@ionic/core/components/ion-fab.js';\nimport { defineCustomElement as defineCustomElement$i } from '@ionic/core/components/ion-fab-list.js';\nimport { defineCustomElement as defineCustomElement$j } from '@ionic/core/components/ion-footer.js';\nimport { defineCustomElement as defineCustomElement$k } from '@ionic/core/components/ion-grid.js';\nimport { defineCustomElement as defineCustomElement$l } from '@ionic/core/components/ion-header.js';\nimport { defineCustomElement as defineCustomElement$m } from '@ionic/core/components/ion-img.js';\nimport { defineCustomElement as defineCustomElement$n } from '@ionic/core/components/ion-infinite-scroll.js';\nimport { defineCustomElement as defineCustomElement$o } from '@ionic/core/components/ion-infinite-scroll-content.js';\nimport { defineCustomElement as defineCustomElement$p } from '@ionic/core/components/ion-input.js';\nimport { defineCustomElement as defineCustomElement$q } from '@ionic/core/components/ion-item-divider.js';\nimport { defineCustomElement as defineCustomElement$r } from '@ionic/core/components/ion-item-group.js';\nimport { defineCustomElement as defineCustomElement$s } from '@ionic/core/components/ion-item-options.js';\nimport { defineCustomElement as defineCustomElement$t } from '@ionic/core/components/ion-item-sliding.js';\nimport { defineCustomElement as defineCustomElement$u } from '@ionic/core/components/ion-label.js';\nimport { defineCustomElement as defineCustomElement$v } from '@ionic/core/components/ion-list.js';\nimport { defineCustomElement as defineCustomElement$w } from '@ionic/core/components/ion-list-header.js';\nimport { defineCustomElement as defineCustomElement$x } from '@ionic/core/components/ion-menu.js';\nimport { defineCustomElement as defineCustomElement$y } from '@ionic/core/components/ion-menu-button.js';\nimport { defineCustomElement as defineCustomElement$z } from '@ionic/core/components/ion-menu-toggle.js';\nimport { defineCustomElement as defineCustomElement$A } from '@ionic/core/components/ion-nav.js';\nimport { defineCustomElement as defineCustomElement$B } from '@ionic/core/components/ion-nav-link.js';\nimport { defineCustomElement as defineCustomElement$C } from '@ionic/core/components/ion-note.js';\nimport { defineCustomElement as defineCustomElement$D } from '@ionic/core/components/ion-progress-bar.js';\nimport { defineCustomElement as defineCustomElement$E } from '@ionic/core/components/ion-radio.js';\nimport { defineCustomElement as defineCustomElement$F } from '@ionic/core/components/ion-radio-group.js';\nimport { defineCustomElement as defineCustomElement$G } from '@ionic/core/components/ion-range.js';\nimport { defineCustomElement as defineCustomElement$H } from '@ionic/core/components/ion-refresher.js';\nimport { defineCustomElement as defineCustomElement$I } from '@ionic/core/components/ion-refresher-content.js';\nimport { defineCustomElement as defineCustomElement$J } from '@ionic/core/components/ion-reorder.js';\nimport { defineCustomElement as defineCustomElement$K } from '@ionic/core/components/ion-reorder-group.js';\nimport { defineCustomElement as defineCustomElement$L } from '@ionic/core/components/ion-ripple-effect.js';\nimport { defineCustomElement as defineCustomElement$M } from '@ionic/core/components/ion-row.js';\nimport { defineCustomElement as defineCustomElement$N } from '@ionic/core/components/ion-searchbar.js';\nimport { defineCustomElement as defineCustomElement$O } from '@ionic/core/components/ion-segment.js';\nimport { defineCustomElement as defineCustomElement$P } from '@ionic/core/components/ion-segment-button.js';\nimport { defineCustomElement as defineCustomElement$Q } from '@ionic/core/components/ion-select.js';\nimport { defineCustomElement as defineCustomElement$R } from '@ionic/core/components/ion-select-option.js';\nimport { defineCustomElement as defineCustomElement$S } from '@ionic/core/components/ion-skeleton-text.js';\nimport { defineCustomElement as defineCustomElement$T } from '@ionic/core/components/ion-slide.js';\nimport { defineCustomElement as defineCustomElement$U } from '@ionic/core/components/ion-slides.js';\nimport { defineCustomElement as defineCustomElement$V } from '@ionic/core/components/ion-spinner.js';\nimport { defineCustomElement as defineCustomElement$W } from '@ionic/core/components/ion-split-pane.js';\nimport { defineCustomElement as defineCustomElement$X } from '@ionic/core/components/ion-tab.js';\nimport { defineCustomElement as defineCustomElement$Y } from '@ionic/core/components/ion-text.js';\nimport { defineCustomElement as defineCustomElement$Z } from '@ionic/core/components/ion-textarea.js';\nimport { defineCustomElement as defineCustomElement$_ } from '@ionic/core/components/ion-thumbnail.js';\nimport { defineCustomElement as defineCustomElement$$ } from '@ionic/core/components/ion-title.js';\nimport { defineCustomElement as defineCustomElement$10 } from '@ionic/core/components/ion-toggle.js';\nimport { defineCustomElement as defineCustomElement$11 } from '@ionic/core/components/ion-toolbar.js';\nimport { defineCustomElement as defineCustomElement$12 } from '@ionic/core/components/ion-virtual-scroll.js';\nimport { IonBreadcrumb as IonBreadcrumb$1 } from '@ionic/core/components/ion-breadcrumb.js';\nimport { IonButton as IonButton$1 } from '@ionic/core/components/ion-button.js';\nimport { IonCard as IonCard$1 } from '@ionic/core/components/ion-card.js';\nimport { IonFabButton as IonFabButton$1 } from '@ionic/core/components/ion-fab-button.js';\nimport { IonItemOption as IonItemOption$1 } from '@ionic/core/components/ion-item-option.js';\nimport { IonItem as IonItem$1 } from '@ionic/core/components/ion-item.js';\nimport { IonRouterLink as IonRouterLink$1 } from '@ionic/core/components/ion-router-link.js';\nimport { IonAlert as IonAlert$1, defineCustomElement as defineCustomElement$1c } from '@ionic/core/components/ion-alert.js';\nimport { IonLoading as IonLoading$1, defineCustomElement as defineCustomElement$1f } from '@ionic/core/components/ion-loading.js';\nimport { IonToast as IonToast$1, defineCustomElement as defineCustomElement$1d } from '@ionic/core/components/ion-toast.js';\nimport { IonPicker as IonPicker$1, defineCustomElement as defineCustomElement$1e } from '@ionic/core/components/ion-picker.js';\nimport { defineCustomElement as defineCustomElement$13 } from '@ionic/core/components/ion-action-sheet.js';\nimport { defineCustomElement as defineCustomElement$14 } from '@ionic/core/components/ion-modal.js';\nimport { defineCustomElement as defineCustomElement$15 } from '@ionic/core/components/ion-popover.js';\nimport { defineCustomElement as defineCustomElement$1a } from '@ionic/core/components/ion-app.js';\nimport { defineCustomElement as defineCustomElement$18 } from '@ionic/core/components/ion-back-button.js';\nimport { defineCustomElement as defineCustomElement$19 } from '@ionic/core/components/ion-router-outlet.js';\nimport { defineCustomElement as defineCustomElement$17 } from '@ionic/core/components/ion-tab-bar.js';\nimport { defineCustomElement as defineCustomElement$16 } from '@ionic/core/components/ion-tab-button.js';\nimport { defineCustomElement as defineCustomElement$1b } from 'ionicons/components/ion-icon.js';\nvar IonLifeCycleContext = /*@__PURE__*/React.createContext({\n  onIonViewWillEnter: function onIonViewWillEnter() {\n    return;\n  },\n  ionViewWillEnter: function ionViewWillEnter() {\n    return;\n  },\n  onIonViewDidEnter: function onIonViewDidEnter() {\n    return;\n  },\n  ionViewDidEnter: function ionViewDidEnter() {\n    return;\n  },\n  onIonViewWillLeave: function onIonViewWillLeave() {\n    return;\n  },\n  ionViewWillLeave: function ionViewWillLeave() {\n    return;\n  },\n  onIonViewDidLeave: function onIonViewDidLeave() {\n    return;\n  },\n  ionViewDidLeave: function ionViewDidLeave() {\n    return;\n  }\n});\nvar DefaultIonLifeCycleContext = /*#__PURE__*/function () {\n  function DefaultIonLifeCycleContext() {\n    _classCallCheck(this, DefaultIonLifeCycleContext);\n    this.ionViewWillEnterCallbacks = [];\n    this.ionViewDidEnterCallbacks = [];\n    this.ionViewWillLeaveCallbacks = [];\n    this.ionViewDidLeaveCallbacks = [];\n  }\n  _createClass(DefaultIonLifeCycleContext, [{\n    key: \"onIonViewWillEnter\",\n    value: function onIonViewWillEnter(callback) {\n      if (callback.id) {\n        var index = this.ionViewWillEnterCallbacks.findIndex(function (x) {\n          return x.id === callback.id;\n        });\n        if (index > -1) {\n          this.ionViewWillEnterCallbacks[index] = callback;\n        } else {\n          this.ionViewWillEnterCallbacks.push(callback);\n        }\n      } else {\n        this.ionViewWillEnterCallbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"ionViewWillEnter\",\n    value: function ionViewWillEnter() {\n      this.ionViewWillEnterCallbacks.forEach(function (cb) {\n        return cb();\n      });\n    }\n  }, {\n    key: \"onIonViewDidEnter\",\n    value: function onIonViewDidEnter(callback) {\n      if (callback.id) {\n        var index = this.ionViewDidEnterCallbacks.findIndex(function (x) {\n          return x.id === callback.id;\n        });\n        if (index > -1) {\n          this.ionViewDidEnterCallbacks[index] = callback;\n        } else {\n          this.ionViewDidEnterCallbacks.push(callback);\n        }\n      } else {\n        this.ionViewDidEnterCallbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"ionViewDidEnter\",\n    value: function ionViewDidEnter() {\n      this.ionViewDidEnterCallbacks.forEach(function (cb) {\n        return cb();\n      });\n    }\n  }, {\n    key: \"onIonViewWillLeave\",\n    value: function onIonViewWillLeave(callback) {\n      if (callback.id) {\n        var index = this.ionViewWillLeaveCallbacks.findIndex(function (x) {\n          return x.id === callback.id;\n        });\n        if (index > -1) {\n          this.ionViewWillLeaveCallbacks[index] = callback;\n        } else {\n          this.ionViewWillLeaveCallbacks.push(callback);\n        }\n      } else {\n        this.ionViewWillLeaveCallbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"ionViewWillLeave\",\n    value: function ionViewWillLeave() {\n      this.ionViewWillLeaveCallbacks.forEach(function (cb) {\n        return cb();\n      });\n    }\n  }, {\n    key: \"onIonViewDidLeave\",\n    value: function onIonViewDidLeave(callback) {\n      if (callback.id) {\n        var index = this.ionViewDidLeaveCallbacks.findIndex(function (x) {\n          return x.id === callback.id;\n        });\n        if (index > -1) {\n          this.ionViewDidLeaveCallbacks[index] = callback;\n        } else {\n          this.ionViewDidLeaveCallbacks.push(callback);\n        }\n      } else {\n        this.ionViewDidLeaveCallbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"ionViewDidLeave\",\n    value: function ionViewDidLeave() {\n      this.ionViewDidLeaveCallbacks.forEach(function (cb) {\n        return cb();\n      });\n      this.componentCanBeDestroyed();\n    }\n  }, {\n    key: \"onComponentCanBeDestroyed\",\n    value: function onComponentCanBeDestroyed(callback) {\n      this.componentCanBeDestroyedCallback = callback;\n    }\n  }, {\n    key: \"componentCanBeDestroyed\",\n    value: function componentCanBeDestroyed() {\n      if (this.componentCanBeDestroyedCallback) {\n        this.componentCanBeDestroyedCallback();\n      }\n    }\n  }]);\n  return DefaultIonLifeCycleContext;\n}();\nvar withIonLifeCycle = function withIonLifeCycle(WrappedComponent) {\n  return /*#__PURE__*/function (_React$Component) {\n    _inherits(IonLifeCycle, _React$Component);\n    function IonLifeCycle(props) {\n      var _this;\n      _classCallCheck(this, IonLifeCycle);\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(IonLifeCycle).call(this, props));\n      _this.componentRef = React.createRef();\n      return _this;\n    }\n    _createClass(IonLifeCycle, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var element = this.componentRef.current;\n        this.context.onIonViewWillEnter(function () {\n          if (element && element.ionViewWillEnter) {\n            element.ionViewWillEnter();\n          }\n        });\n        this.context.onIonViewDidEnter(function () {\n          if (element && element.ionViewDidEnter) {\n            element.ionViewDidEnter();\n          }\n        });\n        this.context.onIonViewWillLeave(function () {\n          if (element && element.ionViewWillLeave) {\n            element.ionViewWillLeave();\n          }\n        });\n        this.context.onIonViewDidLeave(function () {\n          if (element && element.ionViewDidLeave) {\n            element.ionViewDidLeave();\n          }\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this2 = this;\n        return React.createElement(IonLifeCycleContext.Consumer, null, function (context) {\n          _this2.context = context;\n          return React.createElement(WrappedComponent, Object.assign({\n            ref: _this2.componentRef\n          }, _this2.props));\n        });\n      }\n    }]);\n    return IonLifeCycle;\n  }(React.Component);\n};\nvar useIonViewWillEnter = function useIonViewWillEnter(callback) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var context = useContext(IonLifeCycleContext);\n  var id = useRef();\n  id.current = id.current || Math.floor(Math.random() * 1000000);\n  useEffect(function () {\n    callback.id = id.current;\n    context.onIonViewWillEnter(callback);\n  }, deps);\n};\nvar useIonViewDidEnter = function useIonViewDidEnter(callback) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var context = useContext(IonLifeCycleContext);\n  var id = useRef();\n  id.current = id.current || Math.floor(Math.random() * 1000000);\n  useEffect(function () {\n    callback.id = id.current;\n    context.onIonViewDidEnter(callback);\n  }, deps);\n};\nvar useIonViewWillLeave = function useIonViewWillLeave(callback) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var context = useContext(IonLifeCycleContext);\n  var id = useRef();\n  id.current = id.current || Math.floor(Math.random() * 1000000);\n  useEffect(function () {\n    callback.id = id.current;\n    context.onIonViewWillLeave(callback);\n  }, deps);\n};\nvar useIonViewDidLeave = function useIonViewDidLeave(callback) {\n  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var context = useContext(IonLifeCycleContext);\n  var id = useRef();\n  id.current = id.current || Math.floor(Math.random() * 1000000);\n  useEffect(function () {\n    callback.id = id.current;\n    context.onIonViewDidLeave(callback);\n  }, deps);\n};\nvar NavContext = /*@__PURE__*/React.createContext({\n  getIonRedirect: function getIonRedirect() {\n    return undefined;\n  },\n  getIonRoute: function getIonRoute() {\n    return undefined;\n  },\n  getPageManager: function getPageManager() {\n    return undefined;\n  },\n  getStackManager: function getStackManager() {\n    return undefined;\n  },\n  goBack: function goBack(route) {\n    if (typeof window !== 'undefined') {\n      if (typeof route === 'string') {\n        window.location.pathname = route;\n      } else {\n        window.history.back();\n      }\n    }\n  },\n  navigate: function navigate(path) {\n    if (typeof window !== 'undefined') {\n      window.location.pathname = path;\n    }\n  },\n  hasIonicRouter: function hasIonicRouter() {\n    return false;\n  },\n  routeInfo: undefined,\n  setCurrentTab: function setCurrentTab() {\n    return undefined;\n  },\n  changeTab: function changeTab(_tab, path) {\n    if (typeof window !== 'undefined') {\n      window.location.pathname = path;\n    }\n  },\n  resetTab: function resetTab(_tab, path) {\n    if (typeof window !== 'undefined') {\n      window.location.pathname = path;\n    }\n  }\n});\nvar dashToPascalCase = function dashToPascalCase(str) {\n  return str.toLowerCase().split('-').map(function (segment) {\n    return segment.charAt(0).toUpperCase() + segment.slice(1);\n  }).join('');\n};\nvar camelToDashCase = function camelToDashCase(str) {\n  return str.replace(/([A-Z])/g, function (m) {\n    return \"-\".concat(m[0].toLowerCase());\n  });\n};\nvar attachProps = function attachProps(node, newProps) {\n  var oldProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // some test frameworks don't render DOM elements, so we test here to make sure we are dealing with DOM first\n  if (node instanceof Element) {\n    // add any classes in className to the class list\n    var className = getClassName(node.classList, newProps, oldProps);\n    if (className !== '') {\n      node.className = className;\n    }\n    Object.keys(newProps).forEach(function (name) {\n      if (name === 'children' || name === 'style' || name === 'ref' || name === 'class' || name === 'className' || name === 'forwardedRef') {\n        return;\n      }\n      if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n        var eventName = name.substring(2);\n        var eventNameLc = eventName[0].toLowerCase() + eventName.substring(1);\n        if (!isCoveredByReact(eventNameLc)) {\n          syncEvent(node, eventNameLc, newProps[name]);\n        }\n      } else {\n        node[name] = newProps[name];\n        var propType = typeof newProps[name];\n        if (propType === 'string') {\n          node.setAttribute(camelToDashCase(name), newProps[name]);\n        }\n      }\n    });\n  }\n};\nvar getClassName = function getClassName(classList, newProps, oldProps) {\n  var newClassProp = newProps.className || newProps.class;\n  var oldClassProp = oldProps.className || oldProps.class;\n  // map the classes to Maps for performance\n  var currentClasses = arrayToMap(classList);\n  var incomingPropClasses = arrayToMap(newClassProp ? newClassProp.split(' ') : []);\n  var oldPropClasses = arrayToMap(oldClassProp ? oldClassProp.split(' ') : []);\n  var finalClassNames = [];\n  // loop through each of the current classes on the component\n  // to see if it should be a part of the classNames added\n  currentClasses.forEach(function (currentClass) {\n    if (incomingPropClasses.has(currentClass)) {\n      // add it as its already included in classnames coming in from newProps\n      finalClassNames.push(currentClass);\n      incomingPropClasses.delete(currentClass);\n    } else if (!oldPropClasses.has(currentClass)) {\n      // add it as it has NOT been removed by user\n      finalClassNames.push(currentClass);\n    }\n  });\n  incomingPropClasses.forEach(function (s) {\n    return finalClassNames.push(s);\n  });\n  return finalClassNames.join(' ');\n};\n/**\n * Checks if an event is supported in the current execution environment.\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nvar isCoveredByReact = function isCoveredByReact(eventNameSuffix) {\n  if (typeof document === 'undefined') {\n    return true;\n  } else {\n    var eventName = 'on' + eventNameSuffix;\n    var isSupported = (eventName in document);\n    if (!isSupported) {\n      var element = document.createElement('div');\n      element.setAttribute(eventName, 'return;');\n      isSupported = typeof element[eventName] === 'function';\n    }\n    return isSupported;\n  }\n};\nvar syncEvent = function syncEvent(node, eventName, newEventHandler) {\n  var eventStore = node.__events || (node.__events = {});\n  var oldEventHandler = eventStore[eventName];\n  // Remove old listener so they don't double up.\n  if (oldEventHandler) {\n    node.removeEventListener(eventName, oldEventHandler);\n  }\n  // Bind new listener.\n  node.addEventListener(eventName, eventStore[eventName] = function handler(e) {\n    if (newEventHandler) {\n      newEventHandler.call(this, e);\n    }\n  });\n};\nvar arrayToMap = function arrayToMap(arr) {\n  var map = new Map();\n  arr.forEach(function (s) {\n    return map.set(s, s);\n  });\n  return map;\n};\nvar setRef = function setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref != null) {\n    // Cast as a MutableRef so we can assign current\n    ref.current = value;\n  }\n};\nvar mergeRefs = function mergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n  return function (value) {\n    refs.forEach(function (ref) {\n      setRef(ref, value);\n    });\n  };\n};\nvar createForwardRef$1 = function createForwardRef$1(ReactComponent, displayName) {\n  var forwardRef = function forwardRef(props, ref) {\n    return React.createElement(ReactComponent, Object.assign({}, props, {\n      forwardedRef: ref\n    }));\n  };\n  forwardRef.displayName = displayName;\n  return React.forwardRef(forwardRef);\n};\nvar defineCustomElement = function defineCustomElement(tagName, customElement) {\n  if (customElement !== undefined && typeof customElements !== 'undefined' && !customElements.get(tagName)) {\n    customElements.define(tagName, customElement);\n  }\n};\nvar createReactComponent = function createReactComponent(tagName, ReactComponentContext, manipulatePropsFunction, defineCustomElement) {\n  if (defineCustomElement !== undefined) {\n    defineCustomElement();\n  }\n  var displayName = dashToPascalCase(tagName);\n  var ReactComponent = /*#__PURE__*/function (_React$Component2) {\n    _inherits(ReactComponent, _React$Component2);\n    function ReactComponent(props) {\n      var _this3;\n      _classCallCheck(this, ReactComponent);\n      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ReactComponent).call(this, props));\n      _this3.setComponentElRef = function (element) {\n        _this3.componentEl = element;\n      };\n      return _this3;\n    }\n    _createClass(ReactComponent, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.componentDidUpdate(this.props);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        attachProps(this.componentEl, this.props, prevProps);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _a = this.props,\n          children = _a.children,\n          forwardedRef = _a.forwardedRef,\n          style = _a.style,\n          className = _a.className,\n          ref = _a.ref,\n          cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n        var propsToPass = Object.keys(cProps).reduce(function (acc, name) {\n          if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n            var eventName = name.substring(2).toLowerCase();\n            if (typeof document !== 'undefined' && isCoveredByReact(eventName)) {\n              acc[name] = cProps[name];\n            }\n          } else {\n            acc[name] = cProps[name];\n          }\n          return acc;\n        }, {});\n        if (manipulatePropsFunction) {\n          propsToPass = manipulatePropsFunction(this.props, propsToPass);\n        }\n        var newProps = Object.assign(Object.assign({}, propsToPass), {\n          ref: mergeRefs(forwardedRef, this.setComponentElRef),\n          style: style\n        });\n        /**\n         * We use createElement here instead of\n         * React.createElement to work around a\n         * bug in Vite (https://github.com/vitejs/vite/issues/6104).\n         * React.createElement causes all elements to be rendered\n         * as <tagname> instead of the actual Web Component.\n         */\n        return createElement(tagName, newProps, children);\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return displayName;\n      }\n    }]);\n    return ReactComponent;\n  }(React.Component);\n  // If context was passed to createReactComponent then conditionally add it to the Component Class\n  if (ReactComponentContext) {\n    ReactComponent.contextType = ReactComponentContext;\n  }\n  return createForwardRef$1(ReactComponent, displayName);\n};\n\n/* eslint-disable */\nvar IonAccordion = /*@__PURE__*/createReactComponent('ion-accordion', undefined, undefined, defineCustomElement$1);\nvar IonAccordionGroup = /*@__PURE__*/createReactComponent('ion-accordion-group', undefined, undefined, defineCustomElement$2);\nvar IonAvatar = /*@__PURE__*/createReactComponent('ion-avatar', undefined, undefined, defineCustomElement$3);\nvar IonBackdrop = /*@__PURE__*/createReactComponent('ion-backdrop', undefined, undefined, defineCustomElement$4);\nvar IonBadge = /*@__PURE__*/createReactComponent('ion-badge', undefined, undefined, defineCustomElement$5);\nvar IonBreadcrumbs = /*@__PURE__*/createReactComponent('ion-breadcrumbs', undefined, undefined, defineCustomElement$6);\nvar IonButtons = /*@__PURE__*/createReactComponent('ion-buttons', undefined, undefined, defineCustomElement$7);\nvar IonCardContent = /*@__PURE__*/createReactComponent('ion-card-content', undefined, undefined, defineCustomElement$8);\nvar IonCardHeader = /*@__PURE__*/createReactComponent('ion-card-header', undefined, undefined, defineCustomElement$9);\nvar IonCardSubtitle = /*@__PURE__*/createReactComponent('ion-card-subtitle', undefined, undefined, defineCustomElement$a);\nvar IonCardTitle = /*@__PURE__*/createReactComponent('ion-card-title', undefined, undefined, defineCustomElement$b);\nvar IonCheckbox = /*@__PURE__*/createReactComponent('ion-checkbox', undefined, undefined, defineCustomElement$c);\nvar IonChip = /*@__PURE__*/createReactComponent('ion-chip', undefined, undefined, defineCustomElement$d);\nvar IonCol = /*@__PURE__*/createReactComponent('ion-col', undefined, undefined, defineCustomElement$e);\nvar IonContent = /*@__PURE__*/createReactComponent('ion-content', undefined, undefined, defineCustomElement$f);\nvar IonDatetime = /*@__PURE__*/createReactComponent('ion-datetime', undefined, undefined, defineCustomElement$g);\nvar IonFab = /*@__PURE__*/createReactComponent('ion-fab', undefined, undefined, defineCustomElement$h);\nvar IonFabList = /*@__PURE__*/createReactComponent('ion-fab-list', undefined, undefined, defineCustomElement$i);\nvar IonFooter = /*@__PURE__*/createReactComponent('ion-footer', undefined, undefined, defineCustomElement$j);\nvar IonGrid = /*@__PURE__*/createReactComponent('ion-grid', undefined, undefined, defineCustomElement$k);\nvar IonHeader = /*@__PURE__*/createReactComponent('ion-header', undefined, undefined, defineCustomElement$l);\nvar IonImg = /*@__PURE__*/createReactComponent('ion-img', undefined, undefined, defineCustomElement$m);\nvar IonInfiniteScroll = /*@__PURE__*/createReactComponent('ion-infinite-scroll', undefined, undefined, defineCustomElement$n);\nvar IonInfiniteScrollContent = /*@__PURE__*/createReactComponent('ion-infinite-scroll-content', undefined, undefined, defineCustomElement$o);\nvar IonInput = /*@__PURE__*/createReactComponent('ion-input', undefined, undefined, defineCustomElement$p);\nvar IonItemDivider = /*@__PURE__*/createReactComponent('ion-item-divider', undefined, undefined, defineCustomElement$q);\nvar IonItemGroup = /*@__PURE__*/createReactComponent('ion-item-group', undefined, undefined, defineCustomElement$r);\nvar IonItemOptions = /*@__PURE__*/createReactComponent('ion-item-options', undefined, undefined, defineCustomElement$s);\nvar IonItemSliding = /*@__PURE__*/createReactComponent('ion-item-sliding', undefined, undefined, defineCustomElement$t);\nvar IonLabel = /*@__PURE__*/createReactComponent('ion-label', undefined, undefined, defineCustomElement$u);\nvar IonList = /*@__PURE__*/createReactComponent('ion-list', undefined, undefined, defineCustomElement$v);\nvar IonListHeader = /*@__PURE__*/createReactComponent('ion-list-header', undefined, undefined, defineCustomElement$w);\nvar IonMenu = /*@__PURE__*/createReactComponent('ion-menu', undefined, undefined, defineCustomElement$x);\nvar IonMenuButton = /*@__PURE__*/createReactComponent('ion-menu-button', undefined, undefined, defineCustomElement$y);\nvar IonMenuToggle = /*@__PURE__*/createReactComponent('ion-menu-toggle', undefined, undefined, defineCustomElement$z);\nvar IonNav = /*@__PURE__*/createReactComponent('ion-nav', undefined, undefined, defineCustomElement$A);\nvar IonNavLink = /*@__PURE__*/createReactComponent('ion-nav-link', undefined, undefined, defineCustomElement$B);\nvar IonNote = /*@__PURE__*/createReactComponent('ion-note', undefined, undefined, defineCustomElement$C);\nvar IonProgressBar = /*@__PURE__*/createReactComponent('ion-progress-bar', undefined, undefined, defineCustomElement$D);\nvar IonRadio = /*@__PURE__*/createReactComponent('ion-radio', undefined, undefined, defineCustomElement$E);\nvar IonRadioGroup = /*@__PURE__*/createReactComponent('ion-radio-group', undefined, undefined, defineCustomElement$F);\nvar IonRange = /*@__PURE__*/createReactComponent('ion-range', undefined, undefined, defineCustomElement$G);\nvar IonRefresher = /*@__PURE__*/createReactComponent('ion-refresher', undefined, undefined, defineCustomElement$H);\nvar IonRefresherContent = /*@__PURE__*/createReactComponent('ion-refresher-content', undefined, undefined, defineCustomElement$I);\nvar IonReorder = /*@__PURE__*/createReactComponent('ion-reorder', undefined, undefined, defineCustomElement$J);\nvar IonReorderGroup = /*@__PURE__*/createReactComponent('ion-reorder-group', undefined, undefined, defineCustomElement$K);\nvar IonRippleEffect = /*@__PURE__*/createReactComponent('ion-ripple-effect', undefined, undefined, defineCustomElement$L);\nvar IonRow = /*@__PURE__*/createReactComponent('ion-row', undefined, undefined, defineCustomElement$M);\nvar IonSearchbar = /*@__PURE__*/createReactComponent('ion-searchbar', undefined, undefined, defineCustomElement$N);\nvar IonSegment = /*@__PURE__*/createReactComponent('ion-segment', undefined, undefined, defineCustomElement$O);\nvar IonSegmentButton = /*@__PURE__*/createReactComponent('ion-segment-button', undefined, undefined, defineCustomElement$P);\nvar IonSelect = /*@__PURE__*/createReactComponent('ion-select', undefined, undefined, defineCustomElement$Q);\nvar IonSelectOption = /*@__PURE__*/createReactComponent('ion-select-option', undefined, undefined, defineCustomElement$R);\nvar IonSkeletonText = /*@__PURE__*/createReactComponent('ion-skeleton-text', undefined, undefined, defineCustomElement$S);\nvar IonSlide = /*@__PURE__*/createReactComponent('ion-slide', undefined, undefined, defineCustomElement$T);\nvar IonSlides = /*@__PURE__*/createReactComponent('ion-slides', undefined, undefined, defineCustomElement$U);\nvar IonSpinner = /*@__PURE__*/createReactComponent('ion-spinner', undefined, undefined, defineCustomElement$V);\nvar IonSplitPane = /*@__PURE__*/createReactComponent('ion-split-pane', undefined, undefined, defineCustomElement$W);\nvar IonTab = /*@__PURE__*/createReactComponent('ion-tab', undefined, undefined, defineCustomElement$X);\nvar IonText = /*@__PURE__*/createReactComponent('ion-text', undefined, undefined, defineCustomElement$Y);\nvar IonTextarea = /*@__PURE__*/createReactComponent('ion-textarea', undefined, undefined, defineCustomElement$Z);\nvar IonThumbnail = /*@__PURE__*/createReactComponent('ion-thumbnail', undefined, undefined, defineCustomElement$_);\nvar IonTitle = /*@__PURE__*/createReactComponent('ion-title', undefined, undefined, defineCustomElement$$);\nvar IonToggle = /*@__PURE__*/createReactComponent('ion-toggle', undefined, undefined, defineCustomElement$10);\nvar IonToolbar = /*@__PURE__*/createReactComponent('ion-toolbar', undefined, undefined, defineCustomElement$11);\nvar IonVirtualScroll = /*@__PURE__*/createReactComponent('ion-virtual-scroll', undefined, undefined, defineCustomElement$12);\nvar createForwardRef = function createForwardRef(ReactComponent, displayName) {\n  var forwardRef = function forwardRef(props, ref) {\n    return React.createElement(ReactComponent, Object.assign({}, props, {\n      forwardedRef: ref\n    }));\n  };\n  forwardRef.displayName = displayName;\n  return React.forwardRef(forwardRef);\n};\nvar isPlatform = function isPlatform(platform) {\n  return isPlatform$1(window, platform);\n};\nvar getPlatforms = function getPlatforms() {\n  return getPlatforms$1(window);\n};\nvar getConfig = function getConfig() {\n  if (typeof window !== 'undefined') {\n    var Ionic = window.Ionic;\n    if (Ionic && Ionic.config) {\n      return Ionic.config;\n    }\n  }\n  return null;\n};\nvar createRoutingComponent = function createRoutingComponent(tagName, customElement) {\n  defineCustomElement(tagName, customElement);\n  var displayName = dashToPascalCase(tagName);\n  var ReactComponent = /*#__PURE__*/function (_React$Component3) {\n    _inherits(ReactComponent, _React$Component3);\n    function ReactComponent(props) {\n      var _this4;\n      _classCallCheck(this, ReactComponent);\n      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ReactComponent).call(this, props));\n      _this4.handleClick = function (e) {\n        var _this4$props = _this4.props,\n          routerLink = _this4$props.routerLink,\n          routerDirection = _this4$props.routerDirection,\n          routerOptions = _this4$props.routerOptions,\n          routerAnimation = _this4$props.routerAnimation;\n        if (routerLink !== undefined) {\n          e.preventDefault();\n          _this4.context.navigate(routerLink, routerDirection, undefined, routerAnimation, routerOptions);\n        }\n      };\n      // Create a local ref to to attach props to the wrapped element.\n      _this4.ref = React.createRef();\n      // React refs must be stable (not created inline).\n      _this4.stableMergedRefs = mergeRefs(_this4.ref, _this4.props.forwardedRef);\n      return _this4;\n    }\n    _createClass(ReactComponent, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.componentDidUpdate(this.props);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        var node = this.ref.current;\n        attachProps(node, this.props, prevProps);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this5 = this;\n        var _a = this.props,\n          children = _a.children,\n          forwardedRef = _a.forwardedRef,\n          style = _a.style,\n          className = _a.className,\n          ref = _a.ref,\n          cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n        var propsToPass = Object.keys(cProps).reduce(function (acc, name) {\n          if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n            var eventName = name.substring(2).toLowerCase();\n            if (isCoveredByReact(eventName)) {\n              acc[name] = cProps[name];\n            }\n          } else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {\n            acc[camelToDashCase(name)] = cProps[name];\n          }\n          return acc;\n        }, {});\n        var newProps = Object.assign(Object.assign({}, propsToPass), {\n          ref: this.stableMergedRefs,\n          style: style\n        });\n        if (this.props.routerLink && !this.props.href) {\n          newProps.href = this.props.routerLink;\n        }\n        if (newProps.onClick) {\n          var oldClick = newProps.onClick;\n          newProps.onClick = function (e) {\n            oldClick(e);\n            if (!e.defaultPrevented) {\n              _this5.handleClick(e);\n            }\n          };\n        } else {\n          newProps.onClick = this.handleClick;\n        }\n        return createElement(tagName, newProps, children);\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return displayName;\n      }\n    }, {\n      key: \"contextType\",\n      get: function get() {\n        return NavContext;\n      }\n    }]);\n    return ReactComponent;\n  }(React.Component);\n  return createForwardRef(ReactComponent, displayName);\n};\nvar IonRouterLink = /*@__PURE__*/createRoutingComponent('ion-router-link', IonRouterLink$1);\nvar IonButton = /*@__PURE__*/createRoutingComponent('ion-button', IonButton$1);\nvar IonCard = /*@__PURE__*/createRoutingComponent('ion-card', IonCard$1);\nvar IonFabButton = /*@__PURE__*/createRoutingComponent('ion-fab-button', IonFabButton$1);\nvar IonItem = /*@__PURE__*/createRoutingComponent('ion-item', IonItem$1);\nvar IonItemOption = /*@__PURE__*/createRoutingComponent('ion-item-option', IonItemOption$1);\nvar IonBreadcrumb = /*@__PURE__*/createRoutingComponent('ion-breadcrumb', IonBreadcrumb$1);\nvar createControllerComponent = function createControllerComponent(tagName, controller, customElement) {\n  defineCustomElement(tagName, customElement);\n  var displayName = dashToPascalCase(tagName);\n  var didDismissEventName = \"on\".concat(displayName, \"DidDismiss\");\n  var didPresentEventName = \"on\".concat(displayName, \"DidPresent\");\n  var willDismissEventName = \"on\".concat(displayName, \"WillDismiss\");\n  var willPresentEventName = \"on\".concat(displayName, \"WillPresent\");\n  var Overlay = /*#__PURE__*/function (_React$Component4) {\n    _inherits(Overlay, _React$Component4);\n    function Overlay(props) {\n      var _this6;\n      _classCallCheck(this, Overlay);\n      _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Overlay).call(this, props));\n      _this6.willUnmount = false;\n      _this6.handleDismiss = _this6.handleDismiss.bind(_assertThisInitialized(_assertThisInitialized(_this6)));\n      return _this6;\n    }\n    _createClass(Overlay, [{\n      key: \"componentDidMount\",\n      value: function () {\n        var _componentDidMount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var isOpen;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                /**\n                 * Starting in React v18, strict mode will unmount and remount a component.\n                 * See: https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors\n                 *\n                 * We need to reset this flag when the component is re-mounted so that\n                 * overlay.present() will be called and the overlay will display.\n                 */\n                this.willUnmount = false;\n                isOpen = this.props.isOpen;\n                if (isOpen) {\n                  this.present();\n                }\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, this);\n        }));\n        function componentDidMount() {\n          return _componentDidMount.apply(this, arguments);\n        }\n        return componentDidMount;\n      }()\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.willUnmount = true;\n        if (this.overlay) {\n          this.overlay.dismiss();\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function () {\n        var _componentDidUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(prevProps) {\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n                  this.present(prevProps);\n                }\n                if (!(this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false)) {\n                  _context2.next = 4;\n                  break;\n                }\n                _context2.next = 4;\n                return this.overlay.dismiss();\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2, this);\n        }));\n        function componentDidUpdate(_x) {\n          return _componentDidUpdate.apply(this, arguments);\n        }\n        return componentDidUpdate;\n      }()\n    }, {\n      key: \"handleDismiss\",\n      value: function handleDismiss(event) {\n        if (this.props.onDidDismiss) {\n          this.props.onDidDismiss(event);\n        }\n        setRef(this.props.forwardedRef, null);\n      }\n    }, {\n      key: \"present\",\n      value: function () {\n        var _present = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(prevProps) {\n          var _this7 = this,\n            _attachProps;\n          var _a, cProps;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                _a = this.props, cProps = __rest(_a, [\"isOpen\", \"onDidDismiss\", \"onDidPresent\", \"onWillDismiss\", \"onWillPresent\"]);\n                if (this.overlay) {\n                  this.overlay.remove();\n                }\n                _context3.next = 4;\n                return controller.create(Object.assign({}, cProps));\n              case 4:\n                this.overlay = _context3.sent;\n                attachProps(this.overlay, (_attachProps = {}, _defineProperty(_attachProps, didDismissEventName, this.handleDismiss), _defineProperty(_attachProps, didPresentEventName, function (e) {\n                  return _this7.props.onDidPresent && _this7.props.onDidPresent(e);\n                }), _defineProperty(_attachProps, willDismissEventName, function (e) {\n                  return _this7.props.onWillDismiss && _this7.props.onWillDismiss(e);\n                }), _defineProperty(_attachProps, willPresentEventName, function (e) {\n                  return _this7.props.onWillPresent && _this7.props.onWillPresent(e);\n                }), _attachProps), prevProps);\n                // Check isOpen again since the value could have changed during the async call to controller.create\n                // It's also possible for the component to have become unmounted.\n                if (!(this.props.isOpen === true && this.willUnmount === false)) {\n                  _context3.next = 10;\n                  break;\n                }\n                setRef(this.props.forwardedRef, this.overlay);\n                _context3.next = 10;\n                return this.overlay.present();\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3, this);\n        }));\n        function present(_x2) {\n          return _present.apply(this, arguments);\n        }\n        return present;\n      }()\n    }, {\n      key: \"render\",\n      value: function render() {\n        return null;\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return displayName;\n      }\n    }]);\n    return Overlay;\n  }(React.Component);\n  return React.forwardRef(function (props, ref) {\n    return React.createElement(Overlay, Object.assign({}, props, {\n      forwardedRef: ref\n    }));\n  });\n};\nvar IonAlert = /*@__PURE__*/createControllerComponent('ion-alert', alertController, IonAlert$1);\nvar IonLoading = /*@__PURE__*/createControllerComponent('ion-loading', loadingController, IonLoading$1);\nvar toastController = {\n  create: function create(options) {\n    return toastController$1.create(options);\n  },\n  dismiss: function dismiss(data, role, id) {\n    return toastController$1.dismiss(data, role, id);\n  },\n  getTop: function getTop() {\n    return toastController$1.getTop();\n  }\n};\nvar IonToast = /*@__PURE__*/createControllerComponent('ion-toast', toastController, IonToast$1);\nvar IonPicker = /*@__PURE__*/createControllerComponent('ion-picker', pickerController, IonPicker$1);\nvar createOverlayComponent = function createOverlayComponent(tagName, controller, defineCustomElement) {\n  if (defineCustomElement !== undefined) {\n    defineCustomElement();\n  }\n  var displayName = dashToPascalCase(tagName);\n  var didDismissEventName = \"on\".concat(displayName, \"DidDismiss\");\n  var didPresentEventName = \"on\".concat(displayName, \"DidPresent\");\n  var willDismissEventName = \"on\".concat(displayName, \"WillDismiss\");\n  var willPresentEventName = \"on\".concat(displayName, \"WillPresent\");\n  var Overlay = /*#__PURE__*/function (_React$Component5) {\n    _inherits(Overlay, _React$Component5);\n    function Overlay(props) {\n      var _this8;\n      _classCallCheck(this, Overlay);\n      _this8 = _possibleConstructorReturn(this, _getPrototypeOf(Overlay).call(this, props));\n      _this8.isDismissing = false;\n      if (typeof document !== 'undefined') {\n        _this8.el = document.createElement('div');\n      }\n      _this8.handleDismiss = _this8.handleDismiss.bind(_assertThisInitialized(_assertThisInitialized(_this8)));\n      return _this8;\n    }\n    _createClass(Overlay, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this.props.isOpen) {\n          this.present();\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        if (this.overlay) {\n          this.overlay.dismiss();\n        }\n      }\n    }, {\n      key: \"handleDismiss\",\n      value: function handleDismiss(event) {\n        if (this.props.onDidDismiss) {\n          this.props.onDidDismiss(event);\n        }\n        setRef(this.props.forwardedRef, null);\n      }\n    }, {\n      key: \"shouldComponentUpdate\",\n      value: function shouldComponentUpdate(nextProps) {\n        // Check if the overlay component is about to dismiss\n        if (this.overlay && nextProps.isOpen !== this.props.isOpen && nextProps.isOpen === false) {\n          this.isDismissing = true;\n        }\n        return true;\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function () {\n        var _componentDidUpdate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(prevProps) {\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.overlay) {\n                  attachProps(this.overlay, this.props, prevProps);\n                }\n                if (prevProps.isOpen !== this.props.isOpen && this.props.isOpen === true) {\n                  this.present(prevProps);\n                }\n                if (!(this.overlay && prevProps.isOpen !== this.props.isOpen && this.props.isOpen === false)) {\n                  _context4.next = 7;\n                  break;\n                }\n                _context4.next = 5;\n                return this.overlay.dismiss();\n              case 5:\n                this.isDismissing = false;\n                /**\n                 * Now that the overlay is dismissed\n                 * we need to render again so that any\n                 * inner components will be unmounted\n                 */\n                this.forceUpdate();\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }, _callee4, this);\n        }));\n        function componentDidUpdate(_x3) {\n          return _componentDidUpdate2.apply(this, arguments);\n        }\n        return componentDidUpdate;\n      }()\n    }, {\n      key: \"present\",\n      value: function () {\n        var _present2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(prevProps) {\n          var _this9 = this,\n            _Object$assign;\n          var _a, cProps, elementProps;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) switch (_context5.prev = _context5.next) {\n              case 0:\n                _a = this.props, cProps = __rest(_a, [\"children\", \"isOpen\", \"onDidDismiss\", \"onDidPresent\", \"onWillDismiss\", \"onWillPresent\"]);\n                elementProps = Object.assign(Object.assign({}, cProps), (_Object$assign = {\n                  ref: this.props.forwardedRef\n                }, _defineProperty(_Object$assign, didDismissEventName, this.handleDismiss), _defineProperty(_Object$assign, didPresentEventName, function (e) {\n                  return _this9.props.onDidPresent && _this9.props.onDidPresent(e);\n                }), _defineProperty(_Object$assign, willDismissEventName, function (e) {\n                  return _this9.props.onWillDismiss && _this9.props.onWillDismiss(e);\n                }), _defineProperty(_Object$assign, willPresentEventName, function (e) {\n                  return _this9.props.onWillPresent && _this9.props.onWillPresent(e);\n                }), _Object$assign));\n                _context5.next = 4;\n                return controller.create(Object.assign(Object.assign({}, elementProps), {\n                  component: this.el,\n                  componentProps: {}\n                }));\n              case 4:\n                this.overlay = _context5.sent;\n                setRef(this.props.forwardedRef, this.overlay);\n                attachProps(this.overlay, elementProps, prevProps);\n                _context5.next = 9;\n                return this.overlay.present();\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }, _callee5, this);\n        }));\n        function present(_x4) {\n          return _present2.apply(this, arguments);\n        }\n        return present;\n      }()\n    }, {\n      key: \"render\",\n      value: function render() {\n        /**\n         * Continue to render the component even when\n         * overlay is dismissing otherwise component\n         * will be hidden before animation is done.\n         */\n        return ReactDOM.createPortal(this.props.isOpen || this.isDismissing ? this.props.children : null, this.el);\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return displayName;\n      }\n    }]);\n    return Overlay;\n  }(React.Component);\n  return React.forwardRef(function (props, ref) {\n    return React.createElement(Overlay, Object.assign({}, props, {\n      forwardedRef: ref\n    }));\n  });\n};\nvar actionSheetController = {\n  create: function create(options) {\n    return actionSheetController$1.create(options);\n  },\n  dismiss: function dismiss(data, role, id) {\n    return actionSheetController$1.dismiss(data, role, id);\n  },\n  getTop: function getTop() {\n    return actionSheetController$1.getTop();\n  }\n};\nvar IonActionSheet = /*@__PURE__*/createOverlayComponent('ion-action-sheet', actionSheetController, defineCustomElement$13);\nvar createInlineOverlayComponent = function createInlineOverlayComponent(tagName, defineCustomElement) {\n  if (defineCustomElement) {\n    defineCustomElement();\n  }\n  var displayName = dashToPascalCase(tagName);\n  var ReactComponent = /*#__PURE__*/function (_React$Component6) {\n    _inherits(ReactComponent, _React$Component6);\n    function ReactComponent(props) {\n      var _this10;\n      _classCallCheck(this, ReactComponent);\n      _this10 = _possibleConstructorReturn(this, _getPrototypeOf(ReactComponent).call(this, props));\n      // Create a local ref to to attach props to the wrapped element.\n      _this10.ref = React.createRef();\n      // React refs must be stable (not created inline).\n      _this10.stableMergedRefs = mergeRefs(_this10.ref, _this10.props.forwardedRef);\n      // Component is hidden by default\n      _this10.state = {\n        isOpen: false\n      };\n      // Create a local ref to the inner child element.\n      _this10.wrapperRef = React.createRef();\n      return _this10;\n    }\n    _createClass(ReactComponent, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this11 = this;\n        var _a, _b;\n        this.componentDidUpdate(this.props);\n        /**\n         * Mount the inner component\n         * when overlay is about to open.\n         * Also manually call the onWillPresent\n         * handler if present as setState will\n         * cause the event handlers to be\n         * destroyed and re-created.\n         */\n        (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener('willPresent', function (evt) {\n          _this11.setState({\n            isOpen: true\n          });\n          _this11.props.onWillPresent && _this11.props.onWillPresent(evt);\n        });\n        /**\n         * Unmount the inner component.\n         * React will call Node.removeChild\n         * which expects the child to be\n         * a direct descendent of the parent\n         * but due to the presence of\n         * Web Component slots, this is not\n         * always the case. To work around this\n         * we move the inner component to the root\n         * of the Web Component so React can\n         * cleanup properly.\n         */\n        (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener('didDismiss', function (evt) {\n          var wrapper = _this11.wrapperRef.current;\n          var el = _this11.ref.current;\n          /**\n           * This component might be unmounted already, if the containing\n           * element was removed while the popover was still open. (For\n           * example, if an item contains an inline popover with a button\n           * that removes the item.)\n           */\n          if (wrapper && el) {\n            el.append(wrapper);\n            _this11.setState({\n              isOpen: false\n            });\n          }\n          _this11.props.onDidDismiss && _this11.props.onDidDismiss(evt);\n        });\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        var node = this.ref.current;\n        attachProps(node, this.props, prevProps);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _a = this.props,\n          children = _a.children,\n          forwardedRef = _a.forwardedRef,\n          style = _a.style,\n          className = _a.className,\n          ref = _a.ref,\n          cProps = __rest(_a, [\"children\", \"forwardedRef\", \"style\", \"className\", \"ref\"]);\n        var propsToPass = Object.keys(cProps).reduce(function (acc, name) {\n          if (name.indexOf('on') === 0 && name[2] === name[2].toUpperCase()) {\n            var eventName = name.substring(2).toLowerCase();\n            if (isCoveredByReact(eventName)) {\n              acc[name] = cProps[name];\n            }\n          } else if (['string', 'boolean', 'number'].includes(typeof cProps[name])) {\n            acc[camelToDashCase(name)] = cProps[name];\n          }\n          return acc;\n        }, {});\n        var newProps = Object.assign(Object.assign({}, propsToPass), {\n          ref: this.stableMergedRefs,\n          style: style\n        });\n        /**\n         * We only want the inner component\n         * to be mounted if the overlay is open,\n         * so conditionally render the component\n         * based on the isOpen state.\n         */\n        return createElement(tagName, newProps, this.state.isOpen ? createElement('div', {\n          id: 'ion-react-wrapper',\n          ref: this.wrapperRef,\n          style: {\n            display: 'flex',\n            flexDirection: 'column',\n            height: '100%'\n          }\n        }, children) : null);\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return displayName;\n      }\n    }]);\n    return ReactComponent;\n  }(React.Component);\n  return createForwardRef(ReactComponent, displayName);\n};\nvar IonModal = /*@__PURE__*/createInlineOverlayComponent('ion-modal', defineCustomElement$14);\nvar IonPopover = /*@__PURE__*/createInlineOverlayComponent('ion-popover', defineCustomElement$15);\nvar IonContext = React.createContext({\n  addOverlay: function addOverlay() {\n    return;\n  },\n  removeOverlay: function removeOverlay() {\n    return;\n  }\n});\n\n/**\n * Manages overlays that are added via the useOverlay hook.\n * This is a standalone component so changes to its children don't cause other descendant\n * components to re-render when overlays are added. However, we need to communicate with the IonContext\n * that is set up in <IonApp />, so we register callbacks so when overlays are added to IonContext,\n * they ultimately added here.\n */\nvar IonOverlayManager = function IonOverlayManager(_ref) {\n  var onAddOverlay = _ref.onAddOverlay,\n    onRemoveOverlay = _ref.onRemoveOverlay;\n  /**\n   * Because of the way we're passing around the addOverlay and removeOverlay\n   * callbacks, by the time they finally get called, they use a stale reference\n   * to the state that only has the initial values. So if two overlays are opened\n   * at the same time, both using useIonModal or similar (such as through nesting),\n   * the second will erase the first from the overlays list. This causes the content\n   * of the first overlay to unmount.\n   *\n   * We wrap the state in useRef to ensure the two callbacks always use the most\n   * up-to-date version.\n   *\n   * Further reading: https://stackoverflow.com/a/56554056\n   */\n  var _useState = useState({}),\n    _useState2 = _slicedToArray(_useState, 2),\n    overlays = _useState2[0],\n    setOverlays = _useState2[1];\n  var overlaysRef = useRef({});\n  overlaysRef.current = overlays;\n  useEffect(function () {\n    /* Setup the callbacks that get called from <IonApp /> */\n    onAddOverlay(addOverlay);\n    onRemoveOverlay(removeOverlay);\n  }, []);\n  var addOverlay = function addOverlay(id, component, containerElement) {\n    var newOverlays = Object.assign({}, overlaysRef.current);\n    newOverlays[id] = {\n      component: component,\n      containerElement: containerElement\n    };\n    setOverlays(newOverlays);\n  };\n  var removeOverlay = function removeOverlay(id) {\n    var newOverlays = Object.assign({}, overlaysRef.current);\n    delete newOverlays[id];\n    setOverlays(newOverlays);\n  };\n  var overlayKeys = Object.keys(overlays);\n  return React.createElement(React.Fragment, null, overlayKeys.map(function (key) {\n    var overlay = overlays[key];\n    return ReactDOM.createPortal(overlay.component, overlay.containerElement, \"overlay-\".concat(key));\n  }));\n};\nvar IonTabButtonInner = /*@__PURE__*/createReactComponent('ion-tab-button', undefined, undefined, defineCustomElement$16);\nvar IonTabBarInner = /*@__PURE__*/createReactComponent('ion-tab-bar', undefined, undefined, defineCustomElement$17);\nvar IonBackButtonInner = /*@__PURE__*/createReactComponent('ion-back-button', undefined, undefined, defineCustomElement$18);\nvar IonRouterOutletInner = /*@__PURE__*/createReactComponent('ion-router-outlet', undefined, undefined, defineCustomElement$19);\nvar IonAppInner = /*@__PURE__*/createReactComponent('ion-app', undefined, undefined, defineCustomElement$1a);\n// ionicons\nvar IonIconInner = /*@__PURE__*/createReactComponent('ion-icon', undefined, undefined, defineCustomElement$1b);\nvar IonApp = /*@__PURE__*/function () {\n  return /*#__PURE__*/function (_React$Component7) {\n    _inherits(_class, _React$Component7);\n    function _class(props) {\n      var _this12;\n      _classCallCheck(this, _class);\n      _this12 = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));\n      /*\n        Wire up methods to call into IonOverlayManager\n      */\n      _this12.ionContext = {\n        addOverlay: function addOverlay(id, overlay, containerElement) {\n          if (_this12.addOverlayCallback) {\n            _this12.addOverlayCallback(id, overlay, containerElement);\n          }\n        },\n        removeOverlay: function removeOverlay(id) {\n          if (_this12.removeOverlayCallback) {\n            _this12.removeOverlayCallback(id);\n          }\n        }\n      };\n      return _this12;\n    }\n    _createClass(_class, [{\n      key: \"render\",\n      value: function render() {\n        var _this13 = this;\n        return React.createElement(IonContext.Provider, {\n          value: this.ionContext\n        }, React.createElement(IonAppInner, Object.assign({}, this.props), this.props.children), React.createElement(IonOverlayManager, {\n          onAddOverlay: function onAddOverlay(callback) {\n            _this13.addOverlayCallback = callback;\n          },\n          onRemoveOverlay: function onRemoveOverlay(callback) {\n            _this13.removeOverlayCallback = callback;\n          }\n        }));\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return 'IonApp';\n      }\n    }]);\n    return _class;\n  }(React.Component);\n}();\nvar StackContext = React.createContext({\n  registerIonPage: function registerIonPage() {\n    return undefined;\n  },\n  isInOutlet: function isInOutlet() {\n    return false;\n  }\n});\nvar PageManager = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(PageManager, _React$PureComponent);\n  function PageManager(props) {\n    var _this14;\n    _classCallCheck(this, PageManager);\n    _this14 = _possibleConstructorReturn(this, _getPrototypeOf(PageManager).call(this, props));\n    _this14.ionPageElementRef = React.createRef();\n    // React refs must be stable (not created inline).\n    _this14.stableMergedRefs = mergeRefs(_this14.ionPageElementRef, _this14.props.forwardedRef);\n    return _this14;\n  }\n  _createClass(PageManager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.ionPageElementRef.current) {\n        if (this.context.isInOutlet()) {\n          this.ionPageElementRef.current.classList.add('ion-page-invisible');\n        }\n        this.context.registerIonPage(this.ionPageElementRef.current, this.props.routeInfo);\n        this.ionPageElementRef.current.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n        this.ionPageElementRef.current.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n        this.ionPageElementRef.current.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n        this.ionPageElementRef.current.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.ionPageElementRef.current) {\n        this.ionPageElementRef.current.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n        this.ionPageElementRef.current.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n        this.ionPageElementRef.current.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n        this.ionPageElementRef.current.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n      }\n    }\n  }, {\n    key: \"ionViewWillEnterHandler\",\n    value: function ionViewWillEnterHandler() {\n      this.ionLifeCycleContext.ionViewWillEnter();\n    }\n  }, {\n    key: \"ionViewDidEnterHandler\",\n    value: function ionViewDidEnterHandler() {\n      this.ionLifeCycleContext.ionViewDidEnter();\n    }\n  }, {\n    key: \"ionViewWillLeaveHandler\",\n    value: function ionViewWillLeaveHandler() {\n      this.ionLifeCycleContext.ionViewWillLeave();\n    }\n  }, {\n    key: \"ionViewDidLeaveHandler\",\n    value: function ionViewDidLeaveHandler() {\n      this.ionLifeCycleContext.ionViewDidLeave();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this15 = this;\n      var _a = this.props,\n        className = _a.className,\n        children = _a.children,\n        routeInfo = _a.routeInfo,\n        forwardedRef = _a.forwardedRef,\n        props = __rest(_a, [\"className\", \"children\", \"routeInfo\", \"forwardedRef\"]);\n      return React.createElement(IonLifeCycleContext.Consumer, null, function (context) {\n        _this15.ionLifeCycleContext = context;\n        return React.createElement(\"div\", Object.assign({\n          className: className ? \"\".concat(className, \" ion-page\") : \"ion-page\",\n          ref: _this15.stableMergedRefs\n        }, props), children);\n      });\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return StackContext;\n    }\n  }]);\n  return PageManager;\n}(React.PureComponent);\nvar IonPageInternal = /*#__PURE__*/function (_React$Component8) {\n  _inherits(IonPageInternal, _React$Component8);\n  function IonPageInternal(props) {\n    _classCallCheck(this, IonPageInternal);\n    return _possibleConstructorReturn(this, _getPrototypeOf(IonPageInternal).call(this, props));\n  }\n  _createClass(IonPageInternal, [{\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n        className = _a.className,\n        children = _a.children,\n        forwardedRef = _a.forwardedRef,\n        props = __rest(_a, [\"className\", \"children\", \"forwardedRef\"]);\n      return this.context.hasIonicRouter() ? React.createElement(PageManager, Object.assign({\n        className: className ? \"\".concat(className) : '',\n        routeInfo: this.context.routeInfo,\n        forwardedRef: forwardedRef\n      }, props), children) : React.createElement(\"div\", Object.assign({\n        className: className ? \"ion-page \".concat(className) : 'ion-page',\n        ref: forwardedRef\n      }, props), children);\n    }\n  }], [{\n    key: \"displayName\",\n    get: function get() {\n      return 'IonPage';\n    }\n  }, {\n    key: \"contextType\",\n    get: function get() {\n      return NavContext;\n    }\n  }]);\n  return IonPageInternal;\n}(React.Component);\nvar IonPage = createForwardRef(IonPageInternal, 'IonPage');\nvar IonTabsContext = React.createContext({\n  activeTab: undefined,\n  selectTab: function selectTab() {\n    return false;\n  }\n});\nvar HTMLElementSSR = typeof HTMLElement !== 'undefined' ? HTMLElement : /*#__PURE__*/function () {\n  function _class2() {\n    _classCallCheck(this, _class2);\n  }\n  return _class2;\n}();\nvar OutletPageManager = /*#__PURE__*/function (_React$Component9) {\n  _inherits(OutletPageManager, _React$Component9);\n  function OutletPageManager(props) {\n    _classCallCheck(this, OutletPageManager);\n    return _possibleConstructorReturn(this, _getPrototypeOf(OutletPageManager).call(this, props));\n  }\n  _createClass(OutletPageManager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this16 = this;\n      if (this.ionRouterOutlet) {\n        componentOnReady(this.ionRouterOutlet, function () {\n          _this16.context.registerIonPage(_this16.ionRouterOutlet, _this16.props.routeInfo);\n        });\n        this.ionRouterOutlet.addEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n        this.ionRouterOutlet.addEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n        this.ionRouterOutlet.addEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n        this.ionRouterOutlet.addEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.ionRouterOutlet) {\n        this.ionRouterOutlet.removeEventListener('ionViewWillEnter', this.ionViewWillEnterHandler.bind(this));\n        this.ionRouterOutlet.removeEventListener('ionViewDidEnter', this.ionViewDidEnterHandler.bind(this));\n        this.ionRouterOutlet.removeEventListener('ionViewWillLeave', this.ionViewWillLeaveHandler.bind(this));\n        this.ionRouterOutlet.removeEventListener('ionViewDidLeave', this.ionViewDidLeaveHandler.bind(this));\n      }\n    }\n  }, {\n    key: \"ionViewWillEnterHandler\",\n    value: function ionViewWillEnterHandler() {\n      this.ionLifeCycleContext.ionViewWillEnter();\n    }\n  }, {\n    key: \"ionViewDidEnterHandler\",\n    value: function ionViewDidEnterHandler() {\n      this.ionLifeCycleContext.ionViewDidEnter();\n    }\n  }, {\n    key: \"ionViewWillLeaveHandler\",\n    value: function ionViewWillLeaveHandler() {\n      this.ionLifeCycleContext.ionViewWillLeave();\n    }\n  }, {\n    key: \"ionViewDidLeaveHandler\",\n    value: function ionViewDidLeaveHandler() {\n      this.ionLifeCycleContext.ionViewDidLeave();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this17 = this;\n      var _a = this.props,\n        StackManager = _a.StackManager,\n        children = _a.children,\n        routeInfo = _a.routeInfo,\n        props = __rest(_a, [\"StackManager\", \"children\", \"routeInfo\"]);\n      return React.createElement(IonLifeCycleContext.Consumer, null, function (context) {\n        _this17.ionLifeCycleContext = context;\n        return React.createElement(StackManager, {\n          routeInfo: routeInfo\n        }, React.createElement(IonRouterOutletInner, Object.assign({\n          setRef: function setRef(val) {\n            return _this17.ionRouterOutlet = val;\n          }\n        }, props), children));\n      });\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return StackContext;\n    }\n  }]);\n  return OutletPageManager;\n}(React.Component);\nvar IonRouterOutletContainer = /*#__PURE__*/function (_React$Component10) {\n  _inherits(IonRouterOutletContainer, _React$Component10);\n  function IonRouterOutletContainer(props) {\n    _classCallCheck(this, IonRouterOutletContainer);\n    return _possibleConstructorReturn(this, _getPrototypeOf(IonRouterOutletContainer).call(this, props));\n  }\n  _createClass(IonRouterOutletContainer, [{\n    key: \"render\",\n    value: function render() {\n      var StackManager = this.context.getStackManager();\n      var _a = this.props,\n        children = _a.children,\n        forwardedRef = _a.forwardedRef,\n        props = __rest(_a, [\"children\", \"forwardedRef\"]);\n      return this.context.hasIonicRouter() ? props.ionPage ? React.createElement(OutletPageManager, Object.assign({\n        StackManager: StackManager,\n        routeInfo: this.context.routeInfo\n      }, props), children) : React.createElement(StackManager, {\n        routeInfo: this.context.routeInfo\n      }, React.createElement(IonRouterOutletInner, Object.assign({}, props, {\n        forwardedRef: forwardedRef\n      }), children)) : React.createElement(IonRouterOutletInner, Object.assign({\n        ref: forwardedRef\n      }, this.props), this.props.children);\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return NavContext;\n    }\n  }]);\n  return IonRouterOutletContainer;\n}(React.Component);\nvar IonRouterOutlet = createForwardRef(IonRouterOutletContainer, 'IonRouterOutlet');\nvar IonTabButton = /*@__PURE__*/function () {\n  return /*#__PURE__*/function (_React$Component11) {\n    _inherits(_class3, _React$Component11);\n    function _class3(props) {\n      var _this18;\n      _classCallCheck(this, _class3);\n      _this18 = _possibleConstructorReturn(this, _getPrototypeOf(_class3).call(this, props));\n      _this18.handleIonTabButtonClick = _this18.handleIonTabButtonClick.bind(_assertThisInitialized(_assertThisInitialized(_this18)));\n      return _this18;\n    }\n    _createClass(_class3, [{\n      key: \"handleIonTabButtonClick\",\n      value: function handleIonTabButtonClick() {\n        if (this.props.onClick) {\n          this.props.onClick(new CustomEvent('ionTabButtonClick', {\n            detail: {\n              tab: this.props.tab,\n              href: this.props.href,\n              routeOptions: this.props.routerOptions\n            }\n          }));\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        /**\n         * onClick is excluded from the props, since it has a custom\n         * implementation within IonTabBar.tsx. Calling onClick within this\n         * component would result in duplicate handler calls.\n         */\n        var _a = this.props,\n          rest = __rest(_a, [\"onClick\"]);\n        return React.createElement(IonTabButtonInner, Object.assign({\n          onIonTabButtonClick: this.handleIonTabButtonClick\n        }, rest));\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return 'IonTabButton';\n      }\n    }]);\n    return _class3;\n  }(React.Component);\n}();\nvar IonTabBarUnwrapped = /*#__PURE__*/function (_React$PureComponent2) {\n  _inherits(IonTabBarUnwrapped, _React$PureComponent2);\n  function IonTabBarUnwrapped(props) {\n    var _this19;\n    _classCallCheck(this, IonTabBarUnwrapped);\n    _this19 = _possibleConstructorReturn(this, _getPrototypeOf(IonTabBarUnwrapped).call(this, props));\n    _this19.setActiveTabOnContext = function (_tab) {};\n    var tabs = {};\n    React.Children.forEach(props.children, function (child) {\n      var _a, _b, _c, _d;\n      if (child != null && typeof child === 'object' && child.props && (child.type === IonTabButton || child.type.isTabButton)) {\n        tabs[child.props.tab] = {\n          originalHref: child.props.href,\n          currentHref: child.props.href,\n          originalRouteOptions: child.props.href === ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) ? (_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : undefined,\n          currentRouteOptions: child.props.href === ((_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.pathname) ? (_d = props.routeInfo) === null || _d === void 0 ? void 0 : _d.routeOptions : undefined\n        };\n      }\n    });\n    _this19.state = {\n      tabs: tabs\n    };\n    _this19.onTabButtonClick = _this19.onTabButtonClick.bind(_assertThisInitialized(_assertThisInitialized(_this19)));\n    _this19.renderTabButton = _this19.renderTabButton.bind(_assertThisInitialized(_assertThisInitialized(_this19)));\n    _this19.setActiveTabOnContext = _this19.setActiveTabOnContext.bind(_assertThisInitialized(_assertThisInitialized(_this19)));\n    _this19.selectTab = _this19.selectTab.bind(_assertThisInitialized(_assertThisInitialized(_this19)));\n    return _this19;\n  }\n  _createClass(IonTabBarUnwrapped, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this20 = this;\n      var tabs = this.state.tabs;\n      var tabKeys = Object.keys(tabs);\n      var activeTab = tabKeys.find(function (key) {\n        var href = tabs[key].originalHref;\n        return _this20.props.routeInfo.pathname.startsWith(href);\n      });\n      if (activeTab) {\n        this.setState({\n          activeTab: activeTab\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (this.state.activeTab) {\n        this.setActiveTabOnContext(this.state.activeTab);\n      }\n    }\n  }, {\n    key: \"selectTab\",\n    value: function selectTab(tab) {\n      var tabUrl = this.state.tabs[tab];\n      if (tabUrl) {\n        this.onTabButtonClick(new CustomEvent('ionTabButtonClick', {\n          detail: {\n            href: tabUrl.currentHref,\n            tab: tab,\n            selected: tab === this.state.activeTab,\n            routeOptions: undefined\n          }\n        }));\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"onTabButtonClick\",\n    value: function onTabButtonClick(e, onClickFn) {\n      var tappedTab = this.state.tabs[e.detail.tab];\n      var originalHref = tappedTab.originalHref;\n      var currentHref = e.detail.href;\n      var prevActiveTab = this.state.activeTab;\n      if (onClickFn) {\n        /**\n         * If the user provides an onClick function, we call it\n         * with the original event.\n         */\n        onClickFn(e);\n      }\n      // this.props.onSetCurrentTab(e.detail.tab, this.props.routeInfo);\n      // Clicking the current tab will bring you back to the original href\n      if (prevActiveTab === e.detail.tab) {\n        if (originalHref !== currentHref) {\n          this.context.resetTab(e.detail.tab, originalHref, tappedTab.originalRouteOptions);\n        }\n      } else {\n        if (this.props.onIonTabsWillChange) {\n          this.props.onIonTabsWillChange(new CustomEvent('ionTabWillChange', {\n            detail: {\n              tab: e.detail.tab\n            }\n          }));\n        }\n        if (this.props.onIonTabsDidChange) {\n          this.props.onIonTabsDidChange(new CustomEvent('ionTabDidChange', {\n            detail: {\n              tab: e.detail.tab\n            }\n          }));\n        }\n        this.setActiveTabOnContext(e.detail.tab);\n        this.context.changeTab(e.detail.tab, currentHref, e.detail.routeOptions);\n      }\n    }\n  }, {\n    key: \"renderTabButton\",\n    value: function renderTabButton(activeTab) {\n      var _this21 = this;\n      return function (child) {\n        var _a, _b;\n        if (child != null && child.props && (child.type === IonTabButton || child.type.isTabButton)) {\n          var href = child.props.tab === activeTab ? (_a = _this21.props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname : _this21.state.tabs[child.props.tab].currentHref;\n          var routeOptions = child.props.tab === activeTab ? (_b = _this21.props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions : _this21.state.tabs[child.props.tab].currentRouteOptions;\n          return React.cloneElement(child, {\n            href: href,\n            routeOptions: routeOptions,\n            onClick: function onClick(ev) {\n              return _this21.onTabButtonClick(ev, child.props.onClick);\n            }\n          });\n        }\n        return null;\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var activeTab = this.state.activeTab;\n      return React.createElement(IonTabBarInner, Object.assign({}, this.props, {\n        selectedTab: activeTab\n      }), React.Children.map(this.props.children, this.renderTabButton(activeTab)));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      var _a, _b, _c;\n      var tabs = Object.assign({}, state.tabs);\n      var tabKeys = Object.keys(state.tabs);\n      var activeTab = tabKeys.find(function (key) {\n        var href = state.tabs[key].originalHref;\n        return props.routeInfo.pathname.startsWith(href);\n      });\n      // Check to see if the tab button href has changed, and if so, update it in the tabs state\n      React.Children.forEach(props.children, function (child) {\n        if (child != null && typeof child === 'object' && child.props && (child.type === IonTabButton || child.type.isTabButton)) {\n          var tab = tabs[child.props.tab];\n          if (!tab || tab.originalHref !== child.props.href) {\n            tabs[child.props.tab] = {\n              originalHref: child.props.href,\n              currentHref: child.props.href,\n              originalRouteOptions: child.props.routeOptions,\n              currentRouteOptions: child.props.routeOptions\n            };\n          }\n        }\n      });\n      var prevActiveTab = state.activeTab;\n      if (activeTab && prevActiveTab) {\n        var prevHref = state.tabs[prevActiveTab].currentHref;\n        var prevRouteOptions = state.tabs[prevActiveTab].currentRouteOptions;\n        if (activeTab !== prevActiveTab || prevHref !== ((_a = props.routeInfo) === null || _a === void 0 ? void 0 : _a.pathname) || prevRouteOptions !== ((_b = props.routeInfo) === null || _b === void 0 ? void 0 : _b.routeOptions)) {\n          tabs[activeTab] = {\n            originalHref: tabs[activeTab].originalHref,\n            currentHref: props.routeInfo.pathname + (props.routeInfo.search || ''),\n            originalRouteOptions: tabs[activeTab].originalRouteOptions,\n            currentRouteOptions: (_c = props.routeInfo) === null || _c === void 0 ? void 0 : _c.routeOptions\n          };\n          if (props.routeInfo.routeAction === 'pop' && activeTab !== prevActiveTab) {\n            // If navigating back and the tabs change, set the prev tab back to its original href\n            tabs[prevActiveTab] = {\n              originalHref: tabs[prevActiveTab].originalHref,\n              currentHref: tabs[prevActiveTab].originalHref,\n              originalRouteOptions: tabs[prevActiveTab].originalRouteOptions,\n              currentRouteOptions: tabs[prevActiveTab].currentRouteOptions\n            };\n          }\n        }\n      }\n      activeTab && props.onSetCurrentTab(activeTab, props.routeInfo);\n      return {\n        activeTab: activeTab,\n        tabs: tabs\n      };\n    }\n  }, {\n    key: \"contextType\",\n    get: function get() {\n      return NavContext;\n    }\n  }]);\n  return IonTabBarUnwrapped;\n}(React.PureComponent);\nvar IonTabBarContainer = React.memo(function (_a) {\n  var forwardedRef = _a.forwardedRef,\n    props = __rest(_a, [\"forwardedRef\"]);\n  var context = useContext(NavContext);\n  return React.createElement(IonTabBarUnwrapped, Object.assign({\n    ref: forwardedRef\n  }, props, {\n    routeInfo: props.routeInfo || context.routeInfo || {\n      pathname: window.location.pathname\n    },\n    onSetCurrentTab: context.setCurrentTab\n  }), props.children);\n});\nvar IonTabBar = createForwardRef(IonTabBarContainer, 'IonTabBar');\nvar IonTabsElement = /*#__PURE__*/function (_HTMLElementSSR) {\n  _inherits(IonTabsElement, _HTMLElementSSR);\n  function IonTabsElement() {\n    _classCallCheck(this, IonTabsElement);\n    return _possibleConstructorReturn(this, _getPrototypeOf(IonTabsElement).call(this));\n  }\n  return IonTabsElement;\n}(HTMLElementSSR);\nif (typeof window !== 'undefined' && window.customElements) {\n  var element = window.customElements.get('ion-tabs');\n  if (!element) {\n    window.customElements.define('ion-tabs', IonTabsElement);\n  }\n}\nvar hostStyles = {\n  display: 'flex',\n  position: 'absolute',\n  top: '0',\n  left: '0',\n  right: '0',\n  bottom: '0',\n  flexDirection: 'column',\n  width: '100%',\n  height: '100%',\n  contain: 'layout size style'\n};\nvar tabsInner = {\n  position: 'relative',\n  flex: 1,\n  contain: 'layout size style'\n};\nvar IonTabs = /*@__PURE__*/function () {\n  return /*#__PURE__*/function (_React$Component12) {\n    _inherits(_class4, _React$Component12);\n    function _class4(props) {\n      var _this22;\n      _classCallCheck(this, _class4);\n      _this22 = _possibleConstructorReturn(this, _getPrototypeOf(_class4).call(this, props));\n      _this22.routerOutletRef = React.createRef();\n      _this22.tabBarRef = React.createRef();\n      _this22.ionTabContextState = {\n        activeTab: undefined,\n        selectTab: function selectTab() {\n          return false;\n        }\n      };\n      return _this22;\n    }\n    _createClass(_class4, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this23 = this;\n        if (this.tabBarRef.current) {\n          // Grab initial value\n          this.ionTabContextState.activeTab = this.tabBarRef.current.state.activeTab;\n          // Override method\n          this.tabBarRef.current.setActiveTabOnContext = function (tab) {\n            _this23.ionTabContextState.activeTab = tab;\n          };\n          this.ionTabContextState.selectTab = this.tabBarRef.current.selectTab;\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this24 = this;\n        var outlet;\n        var tabBar;\n        var _a = this.props,\n          className = _a.className,\n          onIonTabsDidChange = _a.onIonTabsDidChange,\n          onIonTabsWillChange = _a.onIonTabsWillChange,\n          props = __rest(_a, [\"className\", \"onIonTabsDidChange\", \"onIonTabsWillChange\"]);\n        var children = typeof this.props.children === 'function' ? this.props.children(this.ionTabContextState) : this.props.children;\n        React.Children.forEach(children, function (child) {\n          if (child == null || typeof child !== 'object' || !child.hasOwnProperty('type')) {\n            return;\n          }\n          if (child.type === IonRouterOutlet || child.type.isRouterOutlet) {\n            outlet = React.cloneElement(child);\n          } else if (child.type === Fragment && child.props.children[0].type === IonRouterOutlet) {\n            outlet = child.props.children[0];\n          }\n          var childProps = {\n            ref: _this24.tabBarRef\n          };\n          /**\n           * Only pass these props\n           * down from IonTabs to IonTabBar\n           * if they are defined, otherwise\n           * if you have a handler set on\n           * IonTabBar it will be overridden.\n           */\n          if (onIonTabsDidChange !== undefined) {\n            childProps = Object.assign(Object.assign({}, childProps), {\n              onIonTabsDidChange: onIonTabsDidChange\n            });\n          }\n          if (onIonTabsWillChange !== undefined) {\n            childProps = Object.assign(Object.assign({}, childProps), {\n              onIonTabsWillChange: onIonTabsWillChange\n            });\n          }\n          if (child.type === IonTabBar || child.type.isTabBar) {\n            tabBar = React.cloneElement(child, childProps);\n          } else if (child.type === Fragment && (child.props.children[1].type === IonTabBar || child.props.children[1].type.isTabBar)) {\n            tabBar = React.cloneElement(child.props.children[1], childProps);\n          }\n        });\n        if (!outlet) {\n          throw new Error('IonTabs must contain an IonRouterOutlet');\n        }\n        if (!tabBar) {\n          throw new Error('IonTabs needs a IonTabBar');\n        }\n        return React.createElement(IonTabsContext.Provider, {\n          value: this.ionTabContextState\n        }, this.context.hasIonicRouter() ? React.createElement(PageManager, Object.assign({\n          className: className ? \"\".concat(className) : '',\n          routeInfo: this.context.routeInfo\n        }, props), React.createElement(\"ion-tabs\", {\n          className: \"ion-tabs\",\n          style: hostStyles\n        }, tabBar.props.slot === 'top' ? tabBar : null, React.createElement(\"div\", {\n          style: tabsInner,\n          className: \"tabs-inner\"\n        }, outlet), tabBar.props.slot === 'bottom' ? tabBar : null)) : React.createElement(\"div\", Object.assign({\n          className: className ? \"\".concat(className) : 'ion-tabs'\n        }, props, {\n          style: hostStyles\n        }), tabBar.props.slot === 'top' ? tabBar : null, React.createElement(\"div\", {\n          style: tabsInner,\n          className: \"tabs-inner\"\n        }, outlet), tabBar.props.slot === 'bottom' ? tabBar : null));\n      }\n    }], [{\n      key: \"contextType\",\n      get: function get() {\n        return NavContext;\n      }\n    }]);\n    return _class4;\n  }(React.Component);\n}();\nvar IonBackButton = /*@__PURE__*/function () {\n  return /*#__PURE__*/function (_React$Component13) {\n    _inherits(_class5, _React$Component13);\n    function _class5() {\n      var _this25;\n      _classCallCheck(this, _class5);\n      _this25 = _possibleConstructorReturn(this, _getPrototypeOf(_class5).apply(this, arguments));\n      _this25.clickButton = function (e) {\n        var _this25$props = _this25.props,\n          defaultHref = _this25$props.defaultHref,\n          routerAnimation = _this25$props.routerAnimation;\n        if (_this25.context.hasIonicRouter()) {\n          e.stopPropagation();\n          _this25.context.goBack(defaultHref, routerAnimation);\n        } else if (defaultHref !== undefined) {\n          window.location.href = defaultHref;\n        }\n      };\n      return _this25;\n    }\n    _createClass(_class5, [{\n      key: \"render\",\n      value: function render() {\n        return React.createElement(IonBackButtonInner, Object.assign({\n          onClick: this.clickButton\n        }, this.props));\n      }\n    }], [{\n      key: \"displayName\",\n      get: function get() {\n        return 'IonBackButton';\n      }\n    }, {\n      key: \"contextType\",\n      get: function get() {\n        return NavContext;\n      }\n    }]);\n    return _class5;\n  }(React.Component);\n}();\nvar IonIconContainer = /*#__PURE__*/function (_React$PureComponent3) {\n  _inherits(IonIconContainer, _React$PureComponent3);\n  function IonIconContainer(props) {\n    var _this26;\n    _classCallCheck(this, IonIconContainer);\n    _this26 = _possibleConstructorReturn(this, _getPrototypeOf(IonIconContainer).call(this, props));\n    if (_this26.props.name) {\n      console.warn('In Ionic React, you import icons from \"ionicons/icons\" and set the icon you imported to the \"icon\" property. Setting the \"name\" property has no effect.');\n    }\n    return _this26;\n  }\n  _createClass(IonIconContainer, [{\n    key: \"render\",\n    value: function render() {\n      var _a, _b;\n      var _c = this.props,\n        icon = _c.icon,\n        ios = _c.ios,\n        md = _c.md,\n        rest = __rest(_c, [\"icon\", \"ios\", \"md\"]);\n      var iconToUse;\n      if (ios || md) {\n        if (isPlatform('ios')) {\n          iconToUse = (_a = ios !== null && ios !== void 0 ? ios : md) !== null && _a !== void 0 ? _a : icon;\n        } else {\n          iconToUse = (_b = md !== null && md !== void 0 ? md : ios) !== null && _b !== void 0 ? _b : icon;\n        }\n      } else {\n        iconToUse = icon;\n      }\n      return React.createElement(IonIconInner, Object.assign({\n        ref: this.props.forwardedRef,\n        icon: iconToUse\n      }, rest), this.props.children);\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return NavContext;\n    }\n  }]);\n  return IonIconContainer;\n}(React.PureComponent);\nvar IonIcon = createForwardRef(IonIconContainer, 'IonIcon');\nvar IonRoute = /*#__PURE__*/function (_React$PureComponent4) {\n  _inherits(IonRoute, _React$PureComponent4);\n  function IonRoute() {\n    _classCallCheck(this, IonRoute);\n    return _possibleConstructorReturn(this, _getPrototypeOf(IonRoute).apply(this, arguments));\n  }\n  _createClass(IonRoute, [{\n    key: \"render\",\n    value: function render() {\n      var IonRouteInner = this.context.getIonRoute();\n      if (!this.context.hasIonicRouter() || !IonRoute) {\n        console.error('You either do not have an Ionic Router package, or your router does not support using <IonRoute>');\n        return null;\n      }\n      return React.createElement(IonRouteInner, Object.assign({}, this.props));\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return NavContext;\n    }\n  }]);\n  return IonRoute;\n}(React.PureComponent);\nvar IonRedirect = /*#__PURE__*/function (_React$PureComponent5) {\n  _inherits(IonRedirect, _React$PureComponent5);\n  function IonRedirect() {\n    _classCallCheck(this, IonRedirect);\n    return _possibleConstructorReturn(this, _getPrototypeOf(IonRedirect).apply(this, arguments));\n  }\n  _createClass(IonRedirect, [{\n    key: \"render\",\n    value: function render() {\n      var IonRedirectInner = this.context.getIonRedirect();\n      if (!this.context.hasIonicRouter() || !IonRedirect) {\n        console.error('You either do not have an Ionic Router package, or your router does not support using <IonRedirect>');\n        return null;\n      }\n      return React.createElement(IonRedirectInner, Object.assign({}, this.props));\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return NavContext;\n    }\n  }]);\n  return IonRedirect;\n}(React.PureComponent);\nvar IonRouterContext = React.createContext({\n  routeInfo: undefined,\n  push: function push() {\n    throw new Error('An Ionic Router is required for IonRouterContext');\n  },\n  back: function back() {\n    throw new Error('An Ionic Router is required for IonRouterContext');\n  },\n  canGoBack: function canGoBack() {\n    throw new Error('An Ionic Router is required for IonRouterContext');\n  },\n  nativeBack: function nativeBack() {\n    throw new Error('An Ionic Router is required for IonRouterContext');\n  }\n});\n/**\n * A hook for more direct control over routing in an Ionic React application. Allows you to pass additional meta-data to the router before the call to the native router.\n */\nfunction useIonRouter() {\n  var context = useContext(IonRouterContext);\n  return {\n    back: context.back,\n    push: context.push,\n    goBack: context.back,\n    canGoBack: context.canGoBack,\n    routeInfo: context.routeInfo\n  };\n}\nvar CreateAnimation = /*#__PURE__*/function (_React$PureComponent6) {\n  _inherits(CreateAnimation, _React$PureComponent6);\n  function CreateAnimation(props) {\n    var _this27;\n    _classCallCheck(this, CreateAnimation);\n    _this27 = _possibleConstructorReturn(this, _getPrototypeOf(CreateAnimation).call(this, props));\n    _this27.nodes = new Map();\n    _this27.animation = createAnimation(props.id);\n    return _this27;\n  }\n  _createClass(CreateAnimation, [{\n    key: \"setupAnimation\",\n    value: function setupAnimation(props) {\n      var animation = this.animation;\n      if (this.nodes.size > 0) {\n        animation.addElement(Array.from(this.nodes.values()));\n      }\n      checkConfig(animation, props);\n      checkPlayback(animation, props);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var props = this.props;\n      this.setupAnimation(props);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var animation = this.animation;\n      var props = this.props;\n      checkConfig(animation, props, prevProps);\n      checkProgress(animation, props, prevProps);\n      checkPlayback(animation, props, prevProps);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this28 = this;\n      var children = this.props.children;\n      return React.createElement(React.Fragment, null, React.Children.map(children, function (child, id) {\n        return React.cloneElement(child, {\n          ref: function ref(el) {\n            return _this28.nodes.set(id, el);\n          }\n        });\n      }));\n    }\n  }]);\n  return CreateAnimation;\n}(React.PureComponent);\nvar checkConfig = function checkConfig(animation) {\n  var currentProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var prevProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var reservedProps = ['children', 'progressStart', 'progressStep', 'progressEnd', 'pause', 'stop', 'destroy', 'play', 'from', 'to', 'fromTo', 'onFinish'];\n  for (var key in currentProps) {\n    if (currentProps.hasOwnProperty(key) && !reservedProps.includes(key) && currentProps[key] !== prevProps[key]) {\n      animation[key](currentProps[key]);\n    }\n  }\n  var fromValues = currentProps.from;\n  if (fromValues && fromValues !== prevProps.from) {\n    var values = Array.isArray(fromValues) ? fromValues : [fromValues];\n    values.forEach(function (val) {\n      return animation.from(val.property, val.value);\n    });\n  }\n  var toValues = currentProps.to;\n  if (toValues && toValues !== prevProps.to) {\n    var _values = Array.isArray(toValues) ? toValues : [toValues];\n    _values.forEach(function (val) {\n      return animation.to(val.property, val.value);\n    });\n  }\n  var fromToValues = currentProps.fromTo;\n  if (fromToValues && fromToValues !== prevProps.fromTo) {\n    var _values2 = Array.isArray(fromToValues) ? fromToValues : [fromToValues];\n    _values2.forEach(function (val) {\n      return animation.fromTo(val.property, val.fromValue, val.toValue);\n    });\n  }\n  var onFinishValues = currentProps.onFinish;\n  if (onFinishValues && onFinishValues !== prevProps.onFinish) {\n    var _values3 = Array.isArray(onFinishValues) ? onFinishValues : [onFinishValues];\n    _values3.forEach(function (val) {\n      return animation.onFinish(val.callback, val.opts);\n    });\n  }\n};\nvar checkProgress = function checkProgress(animation) {\n  var currentProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var prevProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a, _b, _c, _d, _e;\n  var progressStart = currentProps.progressStart,\n    progressStep = currentProps.progressStep,\n    progressEnd = currentProps.progressEnd;\n  if (progressStart && (((_a = prevProps.progressStart) === null || _a === void 0 ? void 0 : _a.forceLinearEasing) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.forceLinearEasing) || ((_b = prevProps.progressStart) === null || _b === void 0 ? void 0 : _b.step) !== (progressStart === null || progressStart === void 0 ? void 0 : progressStart.step))) {\n    animation.progressStart(progressStart.forceLinearEasing, progressStart.step);\n  }\n  if (progressStep && ((_c = prevProps.progressStep) === null || _c === void 0 ? void 0 : _c.step) !== (progressStep === null || progressStep === void 0 ? void 0 : progressStep.step)) {\n    animation.progressStep(progressStep.step);\n  }\n  if (progressEnd && (((_d = prevProps.progressEnd) === null || _d === void 0 ? void 0 : _d.playTo) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.playTo) || ((_e = prevProps.progressEnd) === null || _e === void 0 ? void 0 : _e.step) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.step) || (prevProps === null || prevProps === void 0 ? void 0 : prevProps.dur) !== (progressEnd === null || progressEnd === void 0 ? void 0 : progressEnd.dur))) {\n    animation.progressEnd(progressEnd.playTo, progressEnd.step, progressEnd.dur);\n  }\n};\nvar checkPlayback = function checkPlayback(animation) {\n  var currentProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var prevProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!prevProps.play && currentProps.play) {\n    animation.play();\n  }\n  if (!prevProps.pause && currentProps.pause) {\n    animation.pause();\n  }\n  if (!prevProps.stop && currentProps.stop) {\n    animation.stop();\n  }\n  if (!prevProps.destroy && currentProps.destroy) {\n    animation.destroy();\n  }\n};\nfunction useController(displayName, controller, defineCustomElement) {\n  var overlayRef = useRef();\n  var didDismissEventName = useMemo(function () {\n    return \"on\".concat(displayName, \"DidDismiss\");\n  }, [displayName]);\n  var didPresentEventName = useMemo(function () {\n    return \"on\".concat(displayName, \"DidPresent\");\n  }, [displayName]);\n  var willDismissEventName = useMemo(function () {\n    return \"on\".concat(displayName, \"WillDismiss\");\n  }, [displayName]);\n  var willPresentEventName = useMemo(function () {\n    return \"on\".concat(displayName, \"WillPresent\");\n  }, [displayName]);\n  defineCustomElement();\n  var present = useCallback( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options) {\n      var _attachProps2;\n      var onDidDismiss, onWillDismiss, onDidPresent, onWillPresent, rest, handleDismiss;\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!overlayRef.current) {\n              _context6.next = 2;\n              break;\n            }\n            return _context6.abrupt(\"return\");\n          case 2:\n            onDidDismiss = options.onDidDismiss, onWillDismiss = options.onWillDismiss, onDidPresent = options.onDidPresent, onWillPresent = options.onWillPresent, rest = __rest(options, [\"onDidDismiss\", \"onWillDismiss\", \"onDidPresent\", \"onWillPresent\"]);\n            handleDismiss = function handleDismiss(event) {\n              if (onDidDismiss) {\n                onDidDismiss(event);\n              }\n              overlayRef.current = undefined;\n            };\n            _context6.next = 6;\n            return controller.create(Object.assign({}, rest));\n          case 6:\n            overlayRef.current = _context6.sent;\n            attachProps(overlayRef.current, (_attachProps2 = {}, _defineProperty(_attachProps2, didDismissEventName, handleDismiss), _defineProperty(_attachProps2, didPresentEventName, function (e) {\n              return onDidPresent && onDidPresent(e);\n            }), _defineProperty(_attachProps2, willDismissEventName, function (e) {\n              return onWillDismiss && onWillDismiss(e);\n            }), _defineProperty(_attachProps2, willPresentEventName, function (e) {\n              return onWillPresent && onWillPresent(e);\n            }), _attachProps2));\n            overlayRef.current.present();\n          case 9:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n    return function (_x5) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), [controller]);\n  var dismiss = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          _context7.t0 = overlayRef.current;\n          if (!_context7.t0) {\n            _context7.next = 4;\n            break;\n          }\n          _context7.next = 4;\n          return overlayRef.current.dismiss();\n        case 4:\n          overlayRef.current = undefined;\n        case 5:\n        case \"end\":\n          return _context7.stop();\n      }\n    }, _callee7);\n  })), []);\n  return {\n    present: present,\n    dismiss: dismiss\n  };\n}\n\n/**\n * A hook for presenting/dismissing an IonActionSheet component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonActionSheet() {\n  var controller = useController('IonActionSheet', actionSheetController$1, defineCustomElement$13);\n  var present = useCallback(function (buttonsOrOptions, header) {\n    if (Array.isArray(buttonsOrOptions)) {\n      return controller.present({\n        buttons: buttonsOrOptions,\n        header: header\n      });\n    } else {\n      return controller.present(buttonsOrOptions);\n    }\n  }, [controller.present]);\n  return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonAlert component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonAlert() {\n  var controller = useController('IonAlert', alertController, defineCustomElement$1c);\n  var present = useCallback(function (messageOrOptions, buttons) {\n    if (typeof messageOrOptions === 'string') {\n      return controller.present({\n        message: messageOrOptions,\n        buttons: buttons !== null && buttons !== void 0 ? buttons : [{\n          text: 'Ok'\n        }]\n      });\n    } else {\n      return controller.present(messageOrOptions);\n    }\n  }, [controller.present]);\n  return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonToast component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonToast() {\n  var controller = useController('IonToast', toastController$1, defineCustomElement$1d);\n  var present = useCallback(function (messageOrOptions, duration) {\n    if (typeof messageOrOptions === 'string') {\n      return controller.present({\n        message: messageOrOptions,\n        duration: duration\n      });\n    } else {\n      return controller.present(messageOrOptions);\n    }\n  }, [controller.present]);\n  return [present, controller.dismiss];\n}\nvar ids = {\n  main: 0\n};\nvar generateId = function generateId() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n  var _a;\n  var id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n  ids[type] = id;\n  return id.toString();\n};\nfunction useOverlay(displayName, controller, defineCustomElement, component, componentProps) {\n  var overlayRef = useRef();\n  var containerElRef = useRef();\n  var didDismissEventName = useMemo(function () {\n    return \"on\".concat(displayName, \"DidDismiss\");\n  }, [displayName]);\n  var didPresentEventName = useMemo(function () {\n    return \"on\".concat(displayName, \"DidPresent\");\n  }, [displayName]);\n  var willDismissEventName = useMemo(function () {\n    return \"on\".concat(displayName, \"WillDismiss\");\n  }, [displayName]);\n  var willPresentEventName = useMemo(function () {\n    return \"on\".concat(displayName, \"WillPresent\");\n  }, [displayName]);\n  var _useState3 = useState(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    isOpen = _useState4[0],\n    setIsOpen = _useState4[1];\n  var ionContext = useContext(IonContext);\n  var _useState5 = useState(generateId('overlay')),\n    _useState6 = _slicedToArray(_useState5, 1),\n    overlayId = _useState6[0];\n  defineCustomElement();\n  useEffect(function () {\n    if (isOpen && component && containerElRef.current) {\n      if (React.isValidElement(component)) {\n        ionContext.addOverlay(overlayId, component, containerElRef.current);\n      } else {\n        var _element = createElement(component, componentProps);\n        ionContext.addOverlay(overlayId, _element, containerElRef.current);\n      }\n    }\n  }, [component, containerElRef.current, isOpen, componentProps]);\n  var present = useCallback( /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(options) {\n      var _attachProps3;\n      var onDidDismiss, onWillDismiss, onDidPresent, onWillPresent, rest, handleDismiss;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            handleDismiss = function _handleDismiss(event) {\n              if (onDidDismiss) {\n                onDidDismiss(event);\n              }\n              overlayRef.current = undefined;\n              containerElRef.current = undefined;\n              setIsOpen(false);\n              ionContext.removeOverlay(overlayId);\n            };\n            if (!overlayRef.current) {\n              _context8.next = 3;\n              break;\n            }\n            return _context8.abrupt(\"return\");\n          case 3:\n            onDidDismiss = options.onDidDismiss, onWillDismiss = options.onWillDismiss, onDidPresent = options.onDidPresent, onWillPresent = options.onWillPresent, rest = __rest(options, [\"onDidDismiss\", \"onWillDismiss\", \"onDidPresent\", \"onWillPresent\"]);\n            if (typeof document !== 'undefined') {\n              containerElRef.current = document.createElement('div');\n            }\n            _context8.next = 7;\n            return controller.create(Object.assign(Object.assign({}, rest), {\n              component: containerElRef.current\n            }));\n          case 7:\n            overlayRef.current = _context8.sent;\n            attachProps(overlayRef.current, (_attachProps3 = {}, _defineProperty(_attachProps3, didDismissEventName, handleDismiss), _defineProperty(_attachProps3, didPresentEventName, function (e) {\n              return onDidPresent && onDidPresent(e);\n            }), _defineProperty(_attachProps3, willDismissEventName, function (e) {\n              return onWillDismiss && onWillDismiss(e);\n            }), _defineProperty(_attachProps3, willPresentEventName, function (e) {\n              return onWillPresent && onWillPresent(e);\n            }), _attachProps3));\n            overlayRef.current.present();\n            setIsOpen(true);\n          case 11:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8);\n    }));\n    return function (_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }(), []);\n  var dismiss = useCallback( /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(data, role) {\n      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.t0 = overlayRef.current;\n            if (!_context9.t0) {\n              _context9.next = 4;\n              break;\n            }\n            _context9.next = 4;\n            return overlayRef.current.dismiss(data, role);\n          case 4:\n            overlayRef.current = undefined;\n            containerElRef.current = undefined;\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9);\n    }));\n    return function (_x7, _x8) {\n      return _ref5.apply(this, arguments);\n    };\n  }(), []);\n  return {\n    present: present,\n    dismiss: dismiss\n  };\n}\n\n/**\n * A hook for presenting/dismissing an IonModal component\n * @param component The component that the modal will show. Can be a React Component, a functional component, or a JSX Element\n * @param componentProps The props that will be passed to the component, if required\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonModal(component, componentProps) {\n  var controller = useOverlay('IonModal', modalController, defineCustomElement$14, component, componentProps);\n  var present = useCallback(function () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    controller.present(options);\n  }, [controller.present]);\n  return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonPicker component\n * @param component The component that the popover will show. Can be a React Component, a functional component, or a JSX Element\n * @param componentProps The props that will be passed to the component, if required\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonPopover(component, componentProps) {\n  var controller = useOverlay('IonPopover', popoverController, defineCustomElement$15, component, componentProps);\n  var present = useCallback(function () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    controller.present(options);\n  }, [controller.present]);\n  return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonPicker component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonPicker() {\n  var controller = useController('IonPicker', pickerController, defineCustomElement$1e);\n  var present = useCallback(function (columnsOrOptions, buttons) {\n    if (Array.isArray(columnsOrOptions)) {\n      return controller.present({\n        columns: columnsOrOptions,\n        buttons: buttons !== null && buttons !== void 0 ? buttons : [{\n          text: 'Ok'\n        }]\n      });\n    } else {\n      return controller.present(columnsOrOptions);\n    }\n  }, [controller.present]);\n  return [present, controller.dismiss];\n}\n\n/**\n * A hook for presenting/dismissing an IonLoading component\n * @returns Returns the present and dismiss methods in an array\n */\nfunction useIonLoading() {\n  var controller = useController('IonLoading', loadingController, defineCustomElement$1f);\n  var present = useCallback(function () {\n    var messageOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var duration = arguments.length > 1 ? arguments[1] : undefined;\n    var spinner = arguments.length > 2 ? arguments[2] : undefined;\n    if (typeof messageOrOptions === 'string') {\n      return controller.present({\n        message: messageOrOptions,\n        duration: duration,\n        spinner: spinner !== null && spinner !== void 0 ? spinner : 'lines'\n      });\n    } else {\n      return controller.present(messageOrOptions);\n    }\n  }, [controller.present]);\n  return [present, controller.dismiss];\n}\nvar setupIonicReact = function setupIonicReact() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  /**\n   * By default Ionic Framework hides elements that\n   * are not hydrated, but in the CE build there is no\n   * hydration.\n   * TODO: Remove when all integrations have been\n   * migrated to CE build.\n   */\n  if (typeof document !== 'undefined') {\n    document.documentElement.classList.add('ion-ce');\n  }\n  initialize(Object.assign({}, config));\n};\nvar RouteManagerContext = /*@__PURE__*/React.createContext({\n  addViewItem: function addViewItem() {\n    return undefined;\n  },\n  canGoBack: function canGoBack() {\n    return undefined;\n  },\n  clearOutlet: function clearOutlet() {\n    return undefined;\n  },\n  createViewItem: function createViewItem() {\n    return undefined;\n  },\n  findViewItemByPathname: function findViewItemByPathname() {\n    return undefined;\n  },\n  findLeavingViewItemByRouteInfo: function findLeavingViewItemByRouteInfo() {\n    return undefined;\n  },\n  findViewItemByRouteInfo: function findViewItemByRouteInfo() {\n    return undefined;\n  },\n  getChildrenToRender: function getChildrenToRender() {\n    return undefined;\n  },\n  goBack: function goBack() {\n    return undefined;\n  },\n  unMountViewItem: function unMountViewItem() {\n    return undefined;\n  }\n});\nvar ViewLifeCycleManager = /*#__PURE__*/function (_React$Component14) {\n  _inherits(ViewLifeCycleManager, _React$Component14);\n  function ViewLifeCycleManager(props) {\n    var _this29;\n    _classCallCheck(this, ViewLifeCycleManager);\n    _this29 = _possibleConstructorReturn(this, _getPrototypeOf(ViewLifeCycleManager).call(this, props));\n    _this29.ionLifeCycleContext = new DefaultIonLifeCycleContext();\n    _this29._isMounted = false;\n    _this29.ionLifeCycleContext.onComponentCanBeDestroyed(function () {\n      if (!_this29.props.mount) {\n        if (_this29._isMounted) {\n          _this29.setState({\n            show: false\n          }, function () {\n            return _this29.props.removeView();\n          });\n        }\n      }\n    });\n    _this29.state = {\n      show: true\n    };\n    return _this29;\n  }\n  _createClass(ViewLifeCycleManager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._isMounted = true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._isMounted = false;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var show = this.state.show;\n      return React.createElement(IonLifeCycleContext.Provider, {\n        value: this.ionLifeCycleContext\n      }, show && this.props.children);\n    }\n  }]);\n  return ViewLifeCycleManager;\n}(React.Component); // const RESTRICT_SIZE = 100;\nvar LocationHistory = /*#__PURE__*/function () {\n  function LocationHistory() {\n    _classCallCheck(this, LocationHistory);\n    this.locationHistory = [];\n    this.tabHistory = {};\n  }\n  _createClass(LocationHistory, [{\n    key: \"add\",\n    value: function add(routeInfo) {\n      if (routeInfo.routeAction === 'push' || routeInfo.routeAction == null) {\n        this._add(routeInfo);\n      } else if (routeInfo.routeAction === 'pop') {\n        this._pop(routeInfo);\n      } else if (routeInfo.routeAction === 'replace') {\n        this._replace(routeInfo);\n      }\n      if (routeInfo.routeDirection === 'root') {\n        this._clear();\n        this._add(routeInfo);\n      }\n    }\n  }, {\n    key: \"clearTabStack\",\n    value: function clearTabStack(tab) {\n      var _this30 = this;\n      var routeInfos = this._getRouteInfosByKey(tab);\n      if (routeInfos) {\n        routeInfos.forEach(function (ri) {\n          _this30.locationHistory = _this30.locationHistory.filter(function (x) {\n            return x.id !== ri.id;\n          });\n        });\n        this.tabHistory[tab] = [];\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(routeInfo) {\n      var locationIndex = this.locationHistory.findIndex(function (x) {\n        return x.id === routeInfo.id;\n      });\n      if (locationIndex > -1) {\n        this.locationHistory.splice(locationIndex, 1, routeInfo);\n      }\n      var tabArray = this.tabHistory[routeInfo.tab || ''];\n      if (tabArray) {\n        var tabIndex = tabArray.findIndex(function (x) {\n          return x.id === routeInfo.id;\n        });\n        if (tabIndex > -1) {\n          tabArray.splice(tabIndex, 1, routeInfo);\n        } else {\n          tabArray.push(routeInfo);\n        }\n      } else if (routeInfo.tab) {\n        this.tabHistory[routeInfo.tab] = [routeInfo];\n      }\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(routeInfo) {\n      var routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n      if (routeInfos) {\n        // If the latest routeInfo is the same (going back and forth between tabs), replace it\n        if (this._areRoutesEqual(routeInfos[routeInfos.length - 1], routeInfo)) {\n          routeInfos.pop();\n        }\n        routeInfos.push(routeInfo);\n      }\n      this.locationHistory.push(routeInfo);\n    }\n  }, {\n    key: \"_areRoutesEqual\",\n    value: function _areRoutesEqual(route1, route2) {\n      if (!route1 || !route2) {\n        return false;\n      }\n      return route1.pathname === route2.pathname && route1.search === route2.search;\n    }\n  }, {\n    key: \"_pop\",\n    value: function _pop(routeInfo) {\n      var routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n      if (routeInfos) {\n        // Pop the previous route\n        routeInfos.pop();\n        // Replace the current route with an updated version\n        routeInfos.pop();\n        routeInfos.push(routeInfo);\n      }\n      // Pop the previous route\n      this.locationHistory.pop();\n      // Replace the current route with an updated version\n      this.locationHistory.pop();\n      this.locationHistory.push(routeInfo);\n    }\n  }, {\n    key: \"_replace\",\n    value: function _replace(routeInfo) {\n      var routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n      routeInfos && routeInfos.pop();\n      this.locationHistory.pop();\n      this._add(routeInfo);\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      var _this31 = this;\n      var keys = Object.keys(this.tabHistory);\n      keys.forEach(function (k) {\n        return _this31.tabHistory[k] = [];\n      });\n      this.locationHistory = [];\n    }\n  }, {\n    key: \"_getRouteInfosByKey\",\n    value: function _getRouteInfosByKey(key) {\n      var routeInfos;\n      if (key) {\n        routeInfos = this.tabHistory[key];\n        if (!routeInfos) {\n          routeInfos = this.tabHistory[key] = [];\n        }\n      }\n      return routeInfos;\n    }\n  }, {\n    key: \"getFirstRouteInfoForTab\",\n    value: function getFirstRouteInfoForTab(tab) {\n      var routeInfos = this._getRouteInfosByKey(tab);\n      if (routeInfos) {\n        return routeInfos[0];\n      }\n      return undefined;\n    }\n  }, {\n    key: \"getCurrentRouteInfoForTab\",\n    value: function getCurrentRouteInfoForTab(tab) {\n      var routeInfos = this._getRouteInfosByKey(tab);\n      if (routeInfos) {\n        return routeInfos[routeInfos.length - 1];\n      }\n      return undefined;\n    }\n  }, {\n    key: \"findLastLocation\",\n    value: function findLastLocation(routeInfo) {\n      var routeInfos = this._getRouteInfosByKey(routeInfo.tab);\n      if (routeInfos) {\n        for (var i = routeInfos.length - 2; i >= 0; i--) {\n          var ri = routeInfos[i];\n          if (ri) {\n            if (ri.pathname === routeInfo.pushedByRoute) {\n              return ri;\n            }\n          }\n        }\n      }\n      for (var _i = this.locationHistory.length - 2; _i >= 0; _i--) {\n        var _ri = this.locationHistory[_i];\n        if (_ri) {\n          if (_ri.pathname === routeInfo.pushedByRoute) {\n            return _ri;\n          }\n        }\n      }\n      return undefined;\n    }\n  }, {\n    key: \"previous\",\n    value: function previous() {\n      return this.locationHistory[this.locationHistory.length - 2] || this.locationHistory[this.locationHistory.length - 1];\n    }\n  }, {\n    key: \"current\",\n    value: function current() {\n      return this.locationHistory[this.locationHistory.length - 1];\n    }\n  }, {\n    key: \"canGoBack\",\n    value: function canGoBack() {\n      return this.locationHistory.length > 1;\n    }\n  }]);\n  return LocationHistory;\n}();\nvar NavManager = /*#__PURE__*/function (_React$PureComponent7) {\n  _inherits(NavManager, _React$PureComponent7);\n  function NavManager(props) {\n    var _this32;\n    _classCallCheck(this, NavManager);\n    _this32 = _possibleConstructorReturn(this, _getPrototypeOf(NavManager).call(this, props));\n    _this32._isMounted = false;\n    _this32.ionRouterContextValue = {\n      push: function push(pathname, routerDirection, routeAction, routerOptions, animationBuilder) {\n        _this32.navigate(pathname, routerDirection, routeAction, animationBuilder, routerOptions);\n      },\n      back: function back(animationBuilder) {\n        _this32.goBack(undefined, animationBuilder);\n      },\n      canGoBack: function canGoBack() {\n        return _this32.props.locationHistory.canGoBack();\n      },\n      nativeBack: function nativeBack() {\n        return _this32.props.onNativeBack();\n      },\n      routeInfo: _this32.props.routeInfo\n    };\n    _this32.state = {\n      goBack: _this32.goBack.bind(_assertThisInitialized(_assertThisInitialized(_this32))),\n      hasIonicRouter: function hasIonicRouter() {\n        return true;\n      },\n      navigate: _this32.navigate.bind(_assertThisInitialized(_assertThisInitialized(_this32))),\n      getIonRedirect: _this32.getIonRedirect.bind(_assertThisInitialized(_assertThisInitialized(_this32))),\n      getIonRoute: _this32.getIonRoute.bind(_assertThisInitialized(_assertThisInitialized(_this32))),\n      getStackManager: _this32.getStackManager.bind(_assertThisInitialized(_assertThisInitialized(_this32))),\n      getPageManager: _this32.getPageManager.bind(_assertThisInitialized(_assertThisInitialized(_this32))),\n      routeInfo: _this32.props.routeInfo,\n      setCurrentTab: _this32.props.onSetCurrentTab,\n      changeTab: _this32.props.onChangeTab,\n      resetTab: _this32.props.onResetTab\n    };\n    if (typeof document !== 'undefined') {\n      _this32.handleHardwareBackButton = _this32.handleHardwareBackButton.bind(_assertThisInitialized(_assertThisInitialized(_this32)));\n      document.addEventListener('ionBackButton', _this32.handleHardwareBackButton);\n    }\n    return _this32;\n  }\n  _createClass(NavManager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._isMounted = true;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (typeof document !== 'undefined') {\n        document.removeEventListener('ionBackButton', this.handleHardwareBackButton);\n        this._isMounted = false;\n      }\n    }\n  }, {\n    key: \"handleHardwareBackButton\",\n    value: function handleHardwareBackButton(e) {\n      var _this33 = this;\n      e.detail.register(0, function (processNextHandler) {\n        if (_this33._isMounted) {\n          _this33.nativeGoBack();\n          processNextHandler();\n        }\n      });\n    }\n  }, {\n    key: \"goBack\",\n    value: function goBack(route, animationBuilder) {\n      this.props.onNavigateBack(route, animationBuilder);\n    }\n  }, {\n    key: \"nativeGoBack\",\n    value: function nativeGoBack() {\n      this.props.onNativeBack();\n    }\n  }, {\n    key: \"navigate\",\n    value: function navigate(path) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'forward';\n      var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'push';\n      var animationBuilder = arguments.length > 3 ? arguments[3] : undefined;\n      var options = arguments.length > 4 ? arguments[4] : undefined;\n      var tab = arguments.length > 5 ? arguments[5] : undefined;\n      this.props.onNavigate(path, action, direction, animationBuilder, options, tab);\n    }\n  }, {\n    key: \"getPageManager\",\n    value: function getPageManager() {\n      return PageManager;\n    }\n  }, {\n    key: \"getIonRedirect\",\n    value: function getIonRedirect() {\n      return this.props.ionRedirect;\n    }\n  }, {\n    key: \"getIonRoute\",\n    value: function getIonRoute() {\n      return this.props.ionRoute;\n    }\n  }, {\n    key: \"getStackManager\",\n    value: function getStackManager() {\n      return this.props.stackManager;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(NavContext.Provider, {\n        value: Object.assign(Object.assign({}, this.state), {\n          routeInfo: this.props.routeInfo\n        })\n      }, React.createElement(IonRouterContext.Provider, {\n        value: Object.assign(Object.assign({}, this.ionRouterContextValue), {\n          routeInfo: this.props.routeInfo\n        })\n      }, this.props.children));\n    }\n  }]);\n  return NavManager;\n}(React.PureComponent);\nvar ViewStacks = /*#__PURE__*/function () {\n  function ViewStacks() {\n    _classCallCheck(this, ViewStacks);\n    this.viewStacks = {};\n    this.add = this.add.bind(this);\n    this.clear = this.clear.bind(this);\n    this.getViewItemsForOutlet = this.getViewItemsForOutlet.bind(this);\n    this.remove = this.remove.bind(this);\n  }\n  _createClass(ViewStacks, [{\n    key: \"add\",\n    value: function add(viewItem) {\n      var outletId = viewItem.outletId;\n      if (!this.viewStacks[outletId]) {\n        this.viewStacks[outletId] = [viewItem];\n      } else {\n        this.viewStacks[outletId].push(viewItem);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(outletId) {\n      var _this34 = this;\n      // Give some time for the leaving views to transition before removing\n      setTimeout(function () {\n        // console.log('Removing viewstack for outletID ' + outletId);\n        delete _this34.viewStacks[outletId];\n      }, 500);\n    }\n  }, {\n    key: \"getViewItemsForOutlet\",\n    value: function getViewItemsForOutlet(outletId) {\n      return this.viewStacks[outletId] || [];\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(viewItem) {\n      var outletId = viewItem.outletId;\n      var viewStack = this.viewStacks[outletId];\n      if (viewStack) {\n        var viewItemToRemove = viewStack.find(function (x) {\n          return x.id === viewItem.id;\n        });\n        if (viewItemToRemove) {\n          viewItemToRemove.mount = false;\n          this.viewStacks[outletId] = viewStack.filter(function (x) {\n            return x.id !== viewItemToRemove.id;\n          });\n        }\n      }\n    }\n  }, {\n    key: \"getStackIds\",\n    value: function getStackIds() {\n      return Object.keys(this.viewStacks);\n    }\n  }, {\n    key: \"getAllViewItems\",\n    value: function getAllViewItems() {\n      var _this35 = this;\n      var keys = this.getStackIds();\n      var viewItems = [];\n      keys.forEach(function (k) {\n        viewItems.push.apply(viewItems, _toConsumableArray(_this35.viewStacks[k]));\n      });\n      return viewItems;\n    }\n  }]);\n  return ViewStacks;\n}();\nexport { CreateAnimation, DefaultIonLifeCycleContext, IonAccordion, IonAccordionGroup, IonActionSheet, IonAlert, IonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonBreadcrumb, IonBreadcrumbs, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonLifeCycleContext, IonList, IonListHeader, IonLoading, IonMenu, IonMenuButton, IonMenuToggle, IonModal, IonNav, IonNavLink, IonNote, IonPage, IonPicker, IonPopover, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRedirect, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRoute, IonRouterContext, IonRouterLink, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTab, IonTabBar, IonTabButton, IonTabs, IonTabsContext, IonText, IonTextarea, IonThumbnail, IonTitle, IonToast, IonToggle, IonToolbar, IonVirtualScroll, LocationHistory, NavContext, NavManager, RouteManagerContext, StackContext, ViewLifeCycleManager, ViewStacks, generateId, getConfig, getPlatforms, isPlatform, setupIonicReact, useIonActionSheet, useIonAlert, useIonLoading, useIonModal, useIonPicker, useIonPopover, useIonRouter, useIonToast, useIonViewDidEnter, useIonViewDidLeave, useIonViewWillEnter, useIonViewWillLeave, withIonLifeCycle };","map":null,"metadata":{},"sourceType":"module"}